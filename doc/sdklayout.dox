/** \page SDKLayout SDK Layout

\section Overview

\subsection OverviewSdk The SDK Layout

The main idea of the qibuild-based project is that you always end up
with the same layout.

For instance, right after having built you project, you end up with
a directory looking like this:

Here we assume you have a \c foo executable which:
  - depends on a \c bar dynamic library
  - need to read data from a file named \c foo.data
  - need to read configuration from a file named \c foo.cfg


\verbatim
src
|__ foo
    |__ data
        |___ foo.data
    |__ etc
        |__ foo.cfg

build
|___
    sdk
    |__ lib
         |___ libbar.so
    |__ bin
         |__ foo

\endverbatim


When everything is installed, you have something like:

\verbatim

prefix
  |__ lib
      |__ libbar.so
  |__ bin
      |__ foo
  |__ share
      |__ foo
          |__ foo.data
  |__ etc
      |__ foo
          |__ foo.cfg


\endverbatim

\subsection OverviewProblem The problem

Here is a list of common requirements:

 - Find the files \c foo/foo.cfg, \c foo/foo.data in a clean, simple way,
 while making sure the solution works whereas the project is built or installed

 - The executable \c foo may need to write or update its configuration
  files or data but we need to make sure nothing will be written inside
  the installed directory

 - Since there will be several \c foo.cfg files, we need to be able to process
  then in a correct order.


\subsection OverviewSolution The solution

Here is how it works:

 - First we introduce the concept of \b prefix. When something is built,
  the prefix is \c /path/to/build/sdk, when something is installed, the prefix
  is the \c DESTDIR plus the installation prefix.

 - Then we make sure the layout in the build prefix and in the install prefix is
  always the same.
  For instance, we will have CMake rules to be sure that whenever the foo project
  is configured, a copy of \c foo.cfg is placed in \c build/sdk/foo/foo.cfg
  (same thing for data)


  - At last, we provide an easy way to get the prefix anywhere from the c++ code.
  The idea is that it is easy to get the prefix from \c argv0.
  For instance, if \c argv0 is \c /path/to/build/sdk/bin/foo, we can assume
  the prefix is \c /path/to/build/sdk.

*/
