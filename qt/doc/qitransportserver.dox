// -*- C++ -*-

/*!
 * \file      qitransportserver.h
 * \author    Laurent Lec
 * \copyright (C) Aldebaran Robotics
 * \date      2012
 * \since     1.18
 *
 * \class     QiTransportServer
 * \brief     Qt implementation of QiMessaging transport server.
 * \since     1.18
 *
 * \fn        QiTransportServer::QiTransportServer(QObject* parent = 0)
 * \brief     Creates a new transport server.
 * \param[in] parent This argument is passed to QObject's constructor.
 * \since     1.18
 *
 * \fn        QiTransportServer::~QiTransportServer()
 * \brief     Closes the listening socket and destroys the server.
 * \note      Pending sockets are destroyed.
 * \see       QiTransportServer::close()
 * \since     1.18
 *
 * \fn        bool QiTransportServer::listen(const QUrl& listenUrl)
 * \brief     Makes the transport server listen on \a listenUrl.
 * \param[in] listenUrl The url to listen on.
 * \note      Supported protocols (schemes) are "tcp" and "tcps" (SSL over TCP).
 * \return    True on success, false otherwise.
 * \since     1.18
 *
 * \fn        QUrl QiTransportServer::listeningUrl()
 * \brief     Returns the Url on which the server socket is listening.
 * \return    The QUrl is empty if the server is not listening, otherwise, it
 *            returns the listening Url.
 * \see       QiTransportServer::listen()
 * \since     1.18
 *
 * \fn        void QiTransportServer::close()
 * \brief     Makes the server stop listening.
 * \see       QiTransportServer::listen()
 * \since     1.18
 *
 * \fn        bool QiTransportServer::hasPendingConnections()
 * \brief     Checks whether there is any pending connection.
 * \return    True if there is any pending socket, false otherwise.
 * \see       QiTransportServer::nextPendingConnection()
 * \since     1.18
 *
 * \fn        QiTransportServer::nextPendingConnection()
 * \brief     Gets next pending QiTransportSocket.
 * \warning   The user must take care of the deletion of the socket.
 * \note      Incoming sockets can still be retrieved after the server is closed.
 * \see       QiTransportServer::hasPendingConnections()
 * \since     1.18
 *
 * \fn        bool QiTransportServer::isListening()
 * \brief     Checks whether the server is listening.
 * \see       QiTransportServer::listen()
 * \see       QiTransportServer::listeningUrl()
 * \since     1.18
 *
 * \fn        void QiTransportServer::setIdentity(const QByteArray& key, const QByteArray& certificate)
 * \brief     Sets private key and certificate of the server (for "tcps" only).
 * \code{.cpp}
QByteArray key;
QByteArray cert;

QFile fkey("server.key");
if (fkey.open(IO_ReadOnly))
{
  QByteArray key = fkey.readAll();
  fkey.close();
}
else
{
  return;
}

QFile fcert("server.crt");
if (fcert.open(IO_ReadOnly))
{
  QByteArray certificate = fcert.readAll();
  fcert.close();
}
else
{
  return;
}

QiTransportServer server;
server.setIdentity(key, cert);
server.listen("tcps://127.0.0.1:443");
 * \endcode
 * \param     key Private key.
 * \param     certificate Local certificate.
 * \see       QiTransportServer::listen()
 * \since     1.18
  *
 * \fn        QiTransportServer::newConnection()
 * \brief     This signal is emitted when a client connects to the server.
 * \see       QiTransportServer::nextPendingConnection()
 * \see       QiTransportServer::hasPendingConnections()
 * \since     1.18
 *
 * \var       QiTransportServer::_p
 * \brief     Private implementation of QiTransportSocket.
 * \since     1.18
 */
