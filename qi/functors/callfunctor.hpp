
/*
** AUTOGENERATED CODE, DO NOT EDIT
**
** Author(s):
**  - Cedric GESTES <gestes@aldebaran-robotics.com>
**
** Copyright (C) 2010 Aldebaran Robotics
*/

#ifndef  QI_MESSAGING_CALL_FUNCTOR_HPP_
# define QI_MESSAGING_CALL_FUNCTOR_HPP_

#include <qi/collections/variables_list.hpp>
#include <qi/functors/functor.hpp>

namespace qi
{

  template <typename R>
  R callFunctor(Functor *f) {
    qi::Messaging::ArgumentList  args;
    qi::Messaging::VariableValue ret;

    f->call(args, ret);
    return ret.as<R>();
  }

  void callVoidFunctor(Functor *f) {
    qi::Messaging::ArgumentList  args;
    qi::Messaging::VariableValue ret;

    f->call(args, ret);
  }


  template <typename R, typename P0>
  R callFunctor(Functor *f, const P0 &p0) {
    qi::Messaging::ArgumentList  args;
    qi::Messaging::VariableValue ret;

    args.push_back(p0);
    f->call(args, ret);
    return ret.as<R>();
  }

  template <typename P0>
  void callVoidFunctor(Functor *f, const P0 &p0) {
    qi::Messaging::ArgumentList  args;
    qi::Messaging::VariableValue ret;

    args.push_back(p0);
    f->call(args, ret);
  }


  template <typename R, typename P0, typename P1>
  R callFunctor(Functor *f, const P0 &p0, const P1 &p1) {
    qi::Messaging::ArgumentList  args;
    qi::Messaging::VariableValue ret;

    args.push_back(p0); args.push_back(p1);
    f->call(args, ret);
    return ret.as<R>();
  }

  template <typename P0, typename P1>
  void callVoidFunctor(Functor *f, const P0 &p0, const P1 &p1) {
    qi::Messaging::ArgumentList  args;
    qi::Messaging::VariableValue ret;

    args.push_back(p0); args.push_back(p1);
    f->call(args, ret);
  }


  template <typename R, typename P0, typename P1, typename P2>
  R callFunctor(Functor *f, const P0 &p0, const P1 &p1, const P2 &p2) {
    qi::Messaging::ArgumentList  args;
    qi::Messaging::VariableValue ret;

    args.push_back(p0); args.push_back(p1); args.push_back(p2);
    f->call(args, ret);
    return ret.as<R>();
  }

  template <typename P0, typename P1, typename P2>
  void callVoidFunctor(Functor *f, const P0 &p0, const P1 &p1, const P2 &p2) {
    qi::Messaging::ArgumentList  args;
    qi::Messaging::VariableValue ret;

    args.push_back(p0); args.push_back(p1); args.push_back(p2);
    f->call(args, ret);
  }


  template <typename R, typename P0, typename P1, typename P2, typename P3>
  R callFunctor(Functor *f, const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3) {
    qi::Messaging::ArgumentList  args;
    qi::Messaging::VariableValue ret;

    args.push_back(p0); args.push_back(p1); args.push_back(p2); args.push_back(p3);
    f->call(args, ret);
    return ret.as<R>();
  }

  template <typename P0, typename P1, typename P2, typename P3>
  void callVoidFunctor(Functor *f, const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3) {
    qi::Messaging::ArgumentList  args;
    qi::Messaging::VariableValue ret;

    args.push_back(p0); args.push_back(p1); args.push_back(p2); args.push_back(p3);
    f->call(args, ret);
  }


  template <typename R, typename P0, typename P1, typename P2, typename P3, typename P4>
  R callFunctor(Functor *f, const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4) {
    qi::Messaging::ArgumentList  args;
    qi::Messaging::VariableValue ret;

    args.push_back(p0); args.push_back(p1); args.push_back(p2); args.push_back(p3); args.push_back(p4);
    f->call(args, ret);
    return ret.as<R>();
  }

  template <typename P0, typename P1, typename P2, typename P3, typename P4>
  void callVoidFunctor(Functor *f, const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4) {
    qi::Messaging::ArgumentList  args;
    qi::Messaging::VariableValue ret;

    args.push_back(p0); args.push_back(p1); args.push_back(p2); args.push_back(p3); args.push_back(p4);
    f->call(args, ret);
  }


  template <typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5>
  R callFunctor(Functor *f, const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4, const P5 &p5) {
    qi::Messaging::ArgumentList  args;
    qi::Messaging::VariableValue ret;

    args.push_back(p0); args.push_back(p1); args.push_back(p2); args.push_back(p3); args.push_back(p4); args.push_back(p5);
    f->call(args, ret);
    return ret.as<R>();
  }

  template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5>
  void callVoidFunctor(Functor *f, const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4, const P5 &p5) {
    qi::Messaging::ArgumentList  args;
    qi::Messaging::VariableValue ret;

    args.push_back(p0); args.push_back(p1); args.push_back(p2); args.push_back(p3); args.push_back(p4); args.push_back(p5);
    f->call(args, ret);
  }

}
#endif
