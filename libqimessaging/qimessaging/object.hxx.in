#from qibuild_code_generator import *
<%
def generate_argpush_list(count):
    t = "args.push_back(p%(count)d);"
    return generate_list(t, count, sep=" ")
%>
/*
* $autogen
*
*  Author(s):
*  - Chris Kilner  <ckilner@aldebaran-robotics.com>
*  - Cedric Gestes <gestes@aldebaran-robotics.com>
*
*  Copyright (C) 2010, 2012 Aldebaran Robotics
*/

#raw
#pragma once
#ifndef _QI_MESSAGING_OBJECT_HXX_
#define _QI_MESSAGING_OBJECT_HXX_

#include <qimessaging/buffer.hpp>
#include <qimessaging/functor.hpp>
#include <qimessaging/details/boostfunctor.hxx>

namespace qi {
  namespace detail
  {
    // Wrapper class to prevent exposing the 'operator ,'.
    template<typename T> class _PromiseWrap
    {
    public:
      _PromiseWrap(Promise<T>& p)
      : p(p) {}
      /* Workaround to hide warning 'left side of comma has no effect' that
      * gets triggered by user code.
      */
      _PromiseWrap<T>& operator()() { return *this;}
      Promise<T>& p;
    };
    template<> class _PromiseWrap<void>
    {
    public:
      _PromiseWrap(Promise<void>& p)
      : p(p)
      {
        p.setValue(0);
      }
      /* Workaround to hide warning 'left side of comma has no effect' that
      * gets triggered by user code.
      */
      _PromiseWrap<void>& operator()() { return *this;}
      Promise<void>& p;
    };
    template<typename T, typename U> void operator , (_PromiseWrap<T>& p, const U& v)
    {
      p.p.setValue(v);
    }
  }
#end raw
#for $i in $count

  /// <summary> Calls a method </summary>
  /// <returns> The response </returns>
  template <typename R${generate_typename_list($i, begin=True)}>
  qi::Future<R> Object::call(const std::string& method${generate_param_list($i, begin=True)}) {
    //will be deleted by metaCall
    qi::Future<R>                     future;
    qi::Buffer                        breq;
    qi::ODataStream                   ds(breq);
    qi::FunctorParameters             request(breq);
    qi::FunctorResult                 promise;

    std::string sigret;
    std::string signature(method);
    signature += "::(";
   #for $j in range($i)
    signatureFromObject::value(p${j}, signature);
   #end for
    signature += ")";
    signatureFromType<R>::value(sigret);
    bool canBypass = !eventLoop() || eventLoop()->isInEventLoopThread();
    if (canBypass)
    {
      int methodId = metaObject().methodId(signature);
      if (methodId >=0)
      {
        qi::MetaMethod* mm = metaObject().method(methodId);
        if (mm->functor())
        {
          // Try to bypass serialization by fetching the boost::function.
          // We validate that it is of the type we expect by using dynamic_cast.
          // If it is not (paussible cause: missing/extra ref, int vs long)
          // we fallback to serialization.
          //FIXME Use a typedef once someone manages to type it.
          // typedef R (${generate_full_type_list($i)}) Func;
          const detail::BoostFunctor<R (${generate_full_type_list($i)})>* bf =
            dynamic_cast<const detail::BoostFunctor<R (${generate_full_type_list($i)})>*>(mm->functor());
          if (bf)
          {
            const boost::function<R (${generate_full_type_list($i)})>& f = bf->f;
            Promise<R> res;
            detail::_PromiseWrap<R> pw(res);
            // Calls 'res.setValue(f(...))', do nothing for void.
            pw() , f(${generate_arg_list($i)});
            assert(res.future().isReady());
            return res.future();
          }
          else
          {
            qiLogDebug("qi.object") << "Signature mismatch, cannot bypass call "
            << typeid(bf).name() << " " << typeid(*mm->functor()).name();
          }
        }
      }
    }
    makeFunctorResult<R>(&promise, &future);
    #for $j in range($i)
    ds << p${j};
    #end for

    if (qi::detail::sanityCheckAndReport(ds, promise))
      xMetaCall(sigret, signature, request, promise);
    return future;
  }
#end for

#for $i in $count
#if $i == 0
  inline
#else
  template <${generate_typename_list($i, begin=False)}>
#end if
  void Object::emitEvent(const std::string& eventName${generate_param_list($i, begin=True)}) {
    qi::Buffer                        breq;
    qi::ODataStream                    ds(breq);
    qi::FunctorParameters             request(breq);
    #for $j in range($i)
    ds << p${j};
    #end for
    std::string signature(eventName);
    signature += "::(";
    #for $j in range($i)
    signatureFromObject::value(p${j}, signature);
    #end for
    signature += ")";
    if (ds.status() != qi::ODataStream::Status_Ok)
      qiLogError("object.emit") << "Serialization error: " << (int)ds.status();
    else
      xMetaEmit(signature, request);
  }
#end for
}
#raw
#endif  // _QI_MESSAGING_OBJECT_HXX_
#end raw
