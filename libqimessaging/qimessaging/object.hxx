
/*
* AUTOGENERATED CODE, DO NOT EDIT
*
*  Author(s):
*  - Chris Kilner  <ckilner@aldebaran-robotics.com>
*  - Cedric Gestes <gestes@aldebaran-robotics.com>
*
*  Copyright (C) 2010, 2012 Aldebaran Robotics
*/

#pragma once
#ifndef _QI_MESSAGING_OBJECT_HXX_
#define _QI_MESSAGING_OBJECT_HXX_

#include <qimessaging/buffer.hpp>
#include <qimessaging/functor.hpp>
#include <qimessaging/details/boostfunctor.hxx>

namespace qi {
  namespace detail
  {
    // Wrapper class to prevent exposing the 'operator ,'.
    template<typename T> class _PromiseWrap
    {
    public:
      _PromiseWrap(Promise<T>& p)
      : p(p) {}
      /* Workaround to hide warning 'left side of comma has no effect' that
      * gets triggered by user code.
      */
      _PromiseWrap<T>& operator()() { return *this;}
      Promise<T>& p;
    };
    template<> class _PromiseWrap<void>
    {
    public:
      _PromiseWrap(Promise<void>& p)
      : p(p)
      {
        p.setValue(0);
      }
      /* Workaround to hide warning 'left side of comma has no effect' that
      * gets triggered by user code.
      */
      _PromiseWrap<void>& operator()() { return *this;}
      Promise<void>& p;
    };
    template<typename T, typename U> void operator , (_PromiseWrap<T>& p, const U& v)
    {
      p.p.setValue(v);
    }
  }

  /// <summary> Calls a method </summary>
  /// <returns> The response </returns>
  template <typename R>
  qi::Future<R> Object::call(const std::string& method) {
    //will be deleted by metaCall
    qi::Future<R>                     future;
    qi::Buffer                        breq;
    qi::ODataStream                   ds(breq);
    qi::FunctorParameters             request(breq);
    qi::FunctorResult                 promise;

    std::string sigret;
    std::string signature(method);
    signature += "::(";
    signature += ")";
    signatureFromType<R>::value(sigret);
    bool canBypass = !eventLoop() || eventLoop()->isInEventLoopThread();
    if (canBypass)
    {
      int methodId = metaObject().methodId(signature);
      if (methodId >=0)
      {
        qi::MetaMethod* mm = metaObject().method(methodId);
        if (mm->functor())
        {
          // Try to bypass serialization by fetching the boost::function.
          // We validate that it is of the type we expect by using dynamic_cast.
          // If it is not (paussible cause: missing/extra ref, int vs long)
          // we fallback to serialization.
          //FIXME Use a typedef once someone manages to type it.
          // typedef R () Func;
          const detail::BoostFunctor<R ()>* bf =
            dynamic_cast<const detail::BoostFunctor<R ()>*>(mm->functor());
          if (bf)
          {
            const boost::function<R ()>& f = bf->f;
            Promise<R> res;
            detail::_PromiseWrap<R> pw(res);
            // Calls 'res.setValue(f(...))', do nothing for void.
            pw() , f();
            assert(res.future().isReady());
            return res.future();
          }
          else
          {
            qiLogDebug("qi.object") << "Signature mismatch, cannot bypass call "
            << typeid(bf).name() << " " << typeid(*mm->functor()).name();
          }
        }
      }
    }
    makeFunctorResult<R>(&promise, &future);

    if (qi::detail::sanityCheckAndReport(ds, promise))
      xMetaCall(sigret, signature, request, promise);
    return future;
  }

  /// <summary> Calls a method </summary>
  /// <returns> The response </returns>
  template <typename R, typename P0>
  qi::Future<R> Object::call(const std::string& method, const P0 &p0) {
    //will be deleted by metaCall
    qi::Future<R>                     future;
    qi::Buffer                        breq;
    qi::ODataStream                   ds(breq);
    qi::FunctorParameters             request(breq);
    qi::FunctorResult                 promise;

    std::string sigret;
    std::string signature(method);
    signature += "::(";
    signatureFromObject::value(p0, signature);
    signature += ")";
    signatureFromType<R>::value(sigret);
    bool canBypass = !eventLoop() || eventLoop()->isInEventLoopThread();
    if (canBypass)
    {
      int methodId = metaObject().methodId(signature);
      if (methodId >=0)
      {
        qi::MetaMethod* mm = metaObject().method(methodId);
        if (mm->functor())
        {
          // Try to bypass serialization by fetching the boost::function.
          // We validate that it is of the type we expect by using dynamic_cast.
          // If it is not (paussible cause: missing/extra ref, int vs long)
          // we fallback to serialization.
          //FIXME Use a typedef once someone manages to type it.
          // typedef R (const P0 &) Func;
          const detail::BoostFunctor<R (const P0 &)>* bf =
            dynamic_cast<const detail::BoostFunctor<R (const P0 &)>*>(mm->functor());
          if (bf)
          {
            const boost::function<R (const P0 &)>& f = bf->f;
            Promise<R> res;
            detail::_PromiseWrap<R> pw(res);
            // Calls 'res.setValue(f(...))', do nothing for void.
            pw() , f(p0);
            assert(res.future().isReady());
            return res.future();
          }
          else
          {
            qiLogDebug("qi.object") << "Signature mismatch, cannot bypass call "
            << typeid(bf).name() << " " << typeid(*mm->functor()).name();
          }
        }
      }
    }
    makeFunctorResult<R>(&promise, &future);
    ds << p0;

    if (qi::detail::sanityCheckAndReport(ds, promise))
      xMetaCall(sigret, signature, request, promise);
    return future;
  }

  /// <summary> Calls a method </summary>
  /// <returns> The response </returns>
  template <typename R, typename P0, typename P1>
  qi::Future<R> Object::call(const std::string& method, const P0 &p0, const P1 &p1) {
    //will be deleted by metaCall
    qi::Future<R>                     future;
    qi::Buffer                        breq;
    qi::ODataStream                   ds(breq);
    qi::FunctorParameters             request(breq);
    qi::FunctorResult                 promise;

    std::string sigret;
    std::string signature(method);
    signature += "::(";
    signatureFromObject::value(p0, signature);
    signatureFromObject::value(p1, signature);
    signature += ")";
    signatureFromType<R>::value(sigret);
    bool canBypass = !eventLoop() || eventLoop()->isInEventLoopThread();
    if (canBypass)
    {
      int methodId = metaObject().methodId(signature);
      if (methodId >=0)
      {
        qi::MetaMethod* mm = metaObject().method(methodId);
        if (mm->functor())
        {
          // Try to bypass serialization by fetching the boost::function.
          // We validate that it is of the type we expect by using dynamic_cast.
          // If it is not (paussible cause: missing/extra ref, int vs long)
          // we fallback to serialization.
          //FIXME Use a typedef once someone manages to type it.
          // typedef R (const P0 &, const P1 &) Func;
          const detail::BoostFunctor<R (const P0 &, const P1 &)>* bf =
            dynamic_cast<const detail::BoostFunctor<R (const P0 &, const P1 &)>*>(mm->functor());
          if (bf)
          {
            const boost::function<R (const P0 &, const P1 &)>& f = bf->f;
            Promise<R> res;
            detail::_PromiseWrap<R> pw(res);
            // Calls 'res.setValue(f(...))', do nothing for void.
            pw() , f(p0, p1);
            assert(res.future().isReady());
            return res.future();
          }
          else
          {
            qiLogDebug("qi.object") << "Signature mismatch, cannot bypass call "
            << typeid(bf).name() << " " << typeid(*mm->functor()).name();
          }
        }
      }
    }
    makeFunctorResult<R>(&promise, &future);
    ds << p0;
    ds << p1;

    if (qi::detail::sanityCheckAndReport(ds, promise))
      xMetaCall(sigret, signature, request, promise);
    return future;
  }

  /// <summary> Calls a method </summary>
  /// <returns> The response </returns>
  template <typename R, typename P0, typename P1, typename P2>
  qi::Future<R> Object::call(const std::string& method, const P0 &p0, const P1 &p1, const P2 &p2) {
    //will be deleted by metaCall
    qi::Future<R>                     future;
    qi::Buffer                        breq;
    qi::ODataStream                   ds(breq);
    qi::FunctorParameters             request(breq);
    qi::FunctorResult                 promise;

    std::string sigret;
    std::string signature(method);
    signature += "::(";
    signatureFromObject::value(p0, signature);
    signatureFromObject::value(p1, signature);
    signatureFromObject::value(p2, signature);
    signature += ")";
    signatureFromType<R>::value(sigret);
    bool canBypass = !eventLoop() || eventLoop()->isInEventLoopThread();
    if (canBypass)
    {
      int methodId = metaObject().methodId(signature);
      if (methodId >=0)
      {
        qi::MetaMethod* mm = metaObject().method(methodId);
        if (mm->functor())
        {
          // Try to bypass serialization by fetching the boost::function.
          // We validate that it is of the type we expect by using dynamic_cast.
          // If it is not (paussible cause: missing/extra ref, int vs long)
          // we fallback to serialization.
          //FIXME Use a typedef once someone manages to type it.
          // typedef R (const P0 &, const P1 &, const P2 &) Func;
          const detail::BoostFunctor<R (const P0 &, const P1 &, const P2 &)>* bf =
            dynamic_cast<const detail::BoostFunctor<R (const P0 &, const P1 &, const P2 &)>*>(mm->functor());
          if (bf)
          {
            const boost::function<R (const P0 &, const P1 &, const P2 &)>& f = bf->f;
            Promise<R> res;
            detail::_PromiseWrap<R> pw(res);
            // Calls 'res.setValue(f(...))', do nothing for void.
            pw() , f(p0, p1, p2);
            assert(res.future().isReady());
            return res.future();
          }
          else
          {
            qiLogDebug("qi.object") << "Signature mismatch, cannot bypass call "
            << typeid(bf).name() << " " << typeid(*mm->functor()).name();
          }
        }
      }
    }
    makeFunctorResult<R>(&promise, &future);
    ds << p0;
    ds << p1;
    ds << p2;

    if (qi::detail::sanityCheckAndReport(ds, promise))
      xMetaCall(sigret, signature, request, promise);
    return future;
  }

  /// <summary> Calls a method </summary>
  /// <returns> The response </returns>
  template <typename R, typename P0, typename P1, typename P2, typename P3>
  qi::Future<R> Object::call(const std::string& method, const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3) {
    //will be deleted by metaCall
    qi::Future<R>                     future;
    qi::Buffer                        breq;
    qi::ODataStream                   ds(breq);
    qi::FunctorParameters             request(breq);
    qi::FunctorResult                 promise;

    std::string sigret;
    std::string signature(method);
    signature += "::(";
    signatureFromObject::value(p0, signature);
    signatureFromObject::value(p1, signature);
    signatureFromObject::value(p2, signature);
    signatureFromObject::value(p3, signature);
    signature += ")";
    signatureFromType<R>::value(sigret);
    bool canBypass = !eventLoop() || eventLoop()->isInEventLoopThread();
    if (canBypass)
    {
      int methodId = metaObject().methodId(signature);
      if (methodId >=0)
      {
        qi::MetaMethod* mm = metaObject().method(methodId);
        if (mm->functor())
        {
          // Try to bypass serialization by fetching the boost::function.
          // We validate that it is of the type we expect by using dynamic_cast.
          // If it is not (paussible cause: missing/extra ref, int vs long)
          // we fallback to serialization.
          //FIXME Use a typedef once someone manages to type it.
          // typedef R (const P0 &, const P1 &, const P2 &, const P3 &) Func;
          const detail::BoostFunctor<R (const P0 &, const P1 &, const P2 &, const P3 &)>* bf =
            dynamic_cast<const detail::BoostFunctor<R (const P0 &, const P1 &, const P2 &, const P3 &)>*>(mm->functor());
          if (bf)
          {
            const boost::function<R (const P0 &, const P1 &, const P2 &, const P3 &)>& f = bf->f;
            Promise<R> res;
            detail::_PromiseWrap<R> pw(res);
            // Calls 'res.setValue(f(...))', do nothing for void.
            pw() , f(p0, p1, p2, p3);
            assert(res.future().isReady());
            return res.future();
          }
          else
          {
            qiLogDebug("qi.object") << "Signature mismatch, cannot bypass call "
            << typeid(bf).name() << " " << typeid(*mm->functor()).name();
          }
        }
      }
    }
    makeFunctorResult<R>(&promise, &future);
    ds << p0;
    ds << p1;
    ds << p2;
    ds << p3;

    if (qi::detail::sanityCheckAndReport(ds, promise))
      xMetaCall(sigret, signature, request, promise);
    return future;
  }

  /// <summary> Calls a method </summary>
  /// <returns> The response </returns>
  template <typename R, typename P0, typename P1, typename P2, typename P3, typename P4>
  qi::Future<R> Object::call(const std::string& method, const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4) {
    //will be deleted by metaCall
    qi::Future<R>                     future;
    qi::Buffer                        breq;
    qi::ODataStream                   ds(breq);
    qi::FunctorParameters             request(breq);
    qi::FunctorResult                 promise;

    std::string sigret;
    std::string signature(method);
    signature += "::(";
    signatureFromObject::value(p0, signature);
    signatureFromObject::value(p1, signature);
    signatureFromObject::value(p2, signature);
    signatureFromObject::value(p3, signature);
    signatureFromObject::value(p4, signature);
    signature += ")";
    signatureFromType<R>::value(sigret);
    bool canBypass = !eventLoop() || eventLoop()->isInEventLoopThread();
    if (canBypass)
    {
      int methodId = metaObject().methodId(signature);
      if (methodId >=0)
      {
        qi::MetaMethod* mm = metaObject().method(methodId);
        if (mm->functor())
        {
          // Try to bypass serialization by fetching the boost::function.
          // We validate that it is of the type we expect by using dynamic_cast.
          // If it is not (paussible cause: missing/extra ref, int vs long)
          // we fallback to serialization.
          //FIXME Use a typedef once someone manages to type it.
          // typedef R (const P0 &, const P1 &, const P2 &, const P3 &, const P4 &) Func;
          const detail::BoostFunctor<R (const P0 &, const P1 &, const P2 &, const P3 &, const P4 &)>* bf =
            dynamic_cast<const detail::BoostFunctor<R (const P0 &, const P1 &, const P2 &, const P3 &, const P4 &)>*>(mm->functor());
          if (bf)
          {
            const boost::function<R (const P0 &, const P1 &, const P2 &, const P3 &, const P4 &)>& f = bf->f;
            Promise<R> res;
            detail::_PromiseWrap<R> pw(res);
            // Calls 'res.setValue(f(...))', do nothing for void.
            pw() , f(p0, p1, p2, p3, p4);
            assert(res.future().isReady());
            return res.future();
          }
          else
          {
            qiLogDebug("qi.object") << "Signature mismatch, cannot bypass call "
            << typeid(bf).name() << " " << typeid(*mm->functor()).name();
          }
        }
      }
    }
    makeFunctorResult<R>(&promise, &future);
    ds << p0;
    ds << p1;
    ds << p2;
    ds << p3;
    ds << p4;

    if (qi::detail::sanityCheckAndReport(ds, promise))
      xMetaCall(sigret, signature, request, promise);
    return future;
  }

  /// <summary> Calls a method </summary>
  /// <returns> The response </returns>
  template <typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5>
  qi::Future<R> Object::call(const std::string& method, const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4, const P5 &p5) {
    //will be deleted by metaCall
    qi::Future<R>                     future;
    qi::Buffer                        breq;
    qi::ODataStream                   ds(breq);
    qi::FunctorParameters             request(breq);
    qi::FunctorResult                 promise;

    std::string sigret;
    std::string signature(method);
    signature += "::(";
    signatureFromObject::value(p0, signature);
    signatureFromObject::value(p1, signature);
    signatureFromObject::value(p2, signature);
    signatureFromObject::value(p3, signature);
    signatureFromObject::value(p4, signature);
    signatureFromObject::value(p5, signature);
    signature += ")";
    signatureFromType<R>::value(sigret);
    bool canBypass = !eventLoop() || eventLoop()->isInEventLoopThread();
    if (canBypass)
    {
      int methodId = metaObject().methodId(signature);
      if (methodId >=0)
      {
        qi::MetaMethod* mm = metaObject().method(methodId);
        if (mm->functor())
        {
          // Try to bypass serialization by fetching the boost::function.
          // We validate that it is of the type we expect by using dynamic_cast.
          // If it is not (paussible cause: missing/extra ref, int vs long)
          // we fallback to serialization.
          //FIXME Use a typedef once someone manages to type it.
          // typedef R (const P0 &, const P1 &, const P2 &, const P3 &, const P4 &, const P5 &) Func;
          const detail::BoostFunctor<R (const P0 &, const P1 &, const P2 &, const P3 &, const P4 &, const P5 &)>* bf =
            dynamic_cast<const detail::BoostFunctor<R (const P0 &, const P1 &, const P2 &, const P3 &, const P4 &, const P5 &)>*>(mm->functor());
          if (bf)
          {
            const boost::function<R (const P0 &, const P1 &, const P2 &, const P3 &, const P4 &, const P5 &)>& f = bf->f;
            Promise<R> res;
            detail::_PromiseWrap<R> pw(res);
            // Calls 'res.setValue(f(...))', do nothing for void.
            pw() , f(p0, p1, p2, p3, p4, p5);
            assert(res.future().isReady());
            return res.future();
          }
          else
          {
            qiLogDebug("qi.object") << "Signature mismatch, cannot bypass call "
            << typeid(bf).name() << " " << typeid(*mm->functor()).name();
          }
        }
      }
    }
    makeFunctorResult<R>(&promise, &future);
    ds << p0;
    ds << p1;
    ds << p2;
    ds << p3;
    ds << p4;
    ds << p5;

    if (qi::detail::sanityCheckAndReport(ds, promise))
      xMetaCall(sigret, signature, request, promise);
    return future;
  }

  /// <summary> Calls a method </summary>
  /// <returns> The response </returns>
  template <typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
  qi::Future<R> Object::call(const std::string& method, const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4, const P5 &p5, const P6 &p6) {
    //will be deleted by metaCall
    qi::Future<R>                     future;
    qi::Buffer                        breq;
    qi::ODataStream                   ds(breq);
    qi::FunctorParameters             request(breq);
    qi::FunctorResult                 promise;

    std::string sigret;
    std::string signature(method);
    signature += "::(";
    signatureFromObject::value(p0, signature);
    signatureFromObject::value(p1, signature);
    signatureFromObject::value(p2, signature);
    signatureFromObject::value(p3, signature);
    signatureFromObject::value(p4, signature);
    signatureFromObject::value(p5, signature);
    signatureFromObject::value(p6, signature);
    signature += ")";
    signatureFromType<R>::value(sigret);
    bool canBypass = !eventLoop() || eventLoop()->isInEventLoopThread();
    if (canBypass)
    {
      int methodId = metaObject().methodId(signature);
      if (methodId >=0)
      {
        qi::MetaMethod* mm = metaObject().method(methodId);
        if (mm->functor())
        {
          // Try to bypass serialization by fetching the boost::function.
          // We validate that it is of the type we expect by using dynamic_cast.
          // If it is not (paussible cause: missing/extra ref, int vs long)
          // we fallback to serialization.
          //FIXME Use a typedef once someone manages to type it.
          // typedef R (const P0 &, const P1 &, const P2 &, const P3 &, const P4 &, const P5 &, const P6 &) Func;
          const detail::BoostFunctor<R (const P0 &, const P1 &, const P2 &, const P3 &, const P4 &, const P5 &, const P6 &)>* bf =
            dynamic_cast<const detail::BoostFunctor<R (const P0 &, const P1 &, const P2 &, const P3 &, const P4 &, const P5 &, const P6 &)>*>(mm->functor());
          if (bf)
          {
            const boost::function<R (const P0 &, const P1 &, const P2 &, const P3 &, const P4 &, const P5 &, const P6 &)>& f = bf->f;
            Promise<R> res;
            detail::_PromiseWrap<R> pw(res);
            // Calls 'res.setValue(f(...))', do nothing for void.
            pw() , f(p0, p1, p2, p3, p4, p5, p6);
            assert(res.future().isReady());
            return res.future();
          }
          else
          {
            qiLogDebug("qi.object") << "Signature mismatch, cannot bypass call "
            << typeid(bf).name() << " " << typeid(*mm->functor()).name();
          }
        }
      }
    }
    makeFunctorResult<R>(&promise, &future);
    ds << p0;
    ds << p1;
    ds << p2;
    ds << p3;
    ds << p4;
    ds << p5;
    ds << p6;

    if (qi::detail::sanityCheckAndReport(ds, promise))
      xMetaCall(sigret, signature, request, promise);
    return future;
  }

  /// <summary> Calls a method </summary>
  /// <returns> The response </returns>
  template <typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
  qi::Future<R> Object::call(const std::string& method, const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4, const P5 &p5, const P6 &p6, const P7 &p7) {
    //will be deleted by metaCall
    qi::Future<R>                     future;
    qi::Buffer                        breq;
    qi::ODataStream                   ds(breq);
    qi::FunctorParameters             request(breq);
    qi::FunctorResult                 promise;

    std::string sigret;
    std::string signature(method);
    signature += "::(";
    signatureFromObject::value(p0, signature);
    signatureFromObject::value(p1, signature);
    signatureFromObject::value(p2, signature);
    signatureFromObject::value(p3, signature);
    signatureFromObject::value(p4, signature);
    signatureFromObject::value(p5, signature);
    signatureFromObject::value(p6, signature);
    signatureFromObject::value(p7, signature);
    signature += ")";
    signatureFromType<R>::value(sigret);
    bool canBypass = !eventLoop() || eventLoop()->isInEventLoopThread();
    if (canBypass)
    {
      int methodId = metaObject().methodId(signature);
      if (methodId >=0)
      {
        qi::MetaMethod* mm = metaObject().method(methodId);
        if (mm->functor())
        {
          // Try to bypass serialization by fetching the boost::function.
          // We validate that it is of the type we expect by using dynamic_cast.
          // If it is not (paussible cause: missing/extra ref, int vs long)
          // we fallback to serialization.
          //FIXME Use a typedef once someone manages to type it.
          // typedef R (const P0 &, const P1 &, const P2 &, const P3 &, const P4 &, const P5 &, const P6 &, const P7 &) Func;
          const detail::BoostFunctor<R (const P0 &, const P1 &, const P2 &, const P3 &, const P4 &, const P5 &, const P6 &, const P7 &)>* bf =
            dynamic_cast<const detail::BoostFunctor<R (const P0 &, const P1 &, const P2 &, const P3 &, const P4 &, const P5 &, const P6 &, const P7 &)>*>(mm->functor());
          if (bf)
          {
            const boost::function<R (const P0 &, const P1 &, const P2 &, const P3 &, const P4 &, const P5 &, const P6 &, const P7 &)>& f = bf->f;
            Promise<R> res;
            detail::_PromiseWrap<R> pw(res);
            // Calls 'res.setValue(f(...))', do nothing for void.
            pw() , f(p0, p1, p2, p3, p4, p5, p6, p7);
            assert(res.future().isReady());
            return res.future();
          }
          else
          {
            qiLogDebug("qi.object") << "Signature mismatch, cannot bypass call "
            << typeid(bf).name() << " " << typeid(*mm->functor()).name();
          }
        }
      }
    }
    makeFunctorResult<R>(&promise, &future);
    ds << p0;
    ds << p1;
    ds << p2;
    ds << p3;
    ds << p4;
    ds << p5;
    ds << p6;
    ds << p7;

    if (qi::detail::sanityCheckAndReport(ds, promise))
      xMetaCall(sigret, signature, request, promise);
    return future;
  }

  /// <summary> Calls a method </summary>
  /// <returns> The response </returns>
  template <typename R, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8>
  qi::Future<R> Object::call(const std::string& method, const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4, const P5 &p5, const P6 &p6, const P7 &p7, const P8 &p8) {
    //will be deleted by metaCall
    qi::Future<R>                     future;
    qi::Buffer                        breq;
    qi::ODataStream                   ds(breq);
    qi::FunctorParameters             request(breq);
    qi::FunctorResult                 promise;

    std::string sigret;
    std::string signature(method);
    signature += "::(";
    signatureFromObject::value(p0, signature);
    signatureFromObject::value(p1, signature);
    signatureFromObject::value(p2, signature);
    signatureFromObject::value(p3, signature);
    signatureFromObject::value(p4, signature);
    signatureFromObject::value(p5, signature);
    signatureFromObject::value(p6, signature);
    signatureFromObject::value(p7, signature);
    signatureFromObject::value(p8, signature);
    signature += ")";
    signatureFromType<R>::value(sigret);
    bool canBypass = !eventLoop() || eventLoop()->isInEventLoopThread();
    if (canBypass)
    {
      int methodId = metaObject().methodId(signature);
      if (methodId >=0)
      {
        qi::MetaMethod* mm = metaObject().method(methodId);
        if (mm->functor())
        {
          // Try to bypass serialization by fetching the boost::function.
          // We validate that it is of the type we expect by using dynamic_cast.
          // If it is not (paussible cause: missing/extra ref, int vs long)
          // we fallback to serialization.
          //FIXME Use a typedef once someone manages to type it.
          // typedef R (const P0 &, const P1 &, const P2 &, const P3 &, const P4 &, const P5 &, const P6 &, const P7 &, const P8 &) Func;
          const detail::BoostFunctor<R (const P0 &, const P1 &, const P2 &, const P3 &, const P4 &, const P5 &, const P6 &, const P7 &, const P8 &)>* bf =
            dynamic_cast<const detail::BoostFunctor<R (const P0 &, const P1 &, const P2 &, const P3 &, const P4 &, const P5 &, const P6 &, const P7 &, const P8 &)>*>(mm->functor());
          if (bf)
          {
            const boost::function<R (const P0 &, const P1 &, const P2 &, const P3 &, const P4 &, const P5 &, const P6 &, const P7 &, const P8 &)>& f = bf->f;
            Promise<R> res;
            detail::_PromiseWrap<R> pw(res);
            // Calls 'res.setValue(f(...))', do nothing for void.
            pw() , f(p0, p1, p2, p3, p4, p5, p6, p7, p8);
            assert(res.future().isReady());
            return res.future();
          }
          else
          {
            qiLogDebug("qi.object") << "Signature mismatch, cannot bypass call "
            << typeid(bf).name() << " " << typeid(*mm->functor()).name();
          }
        }
      }
    }
    makeFunctorResult<R>(&promise, &future);
    ds << p0;
    ds << p1;
    ds << p2;
    ds << p3;
    ds << p4;
    ds << p5;
    ds << p6;
    ds << p7;
    ds << p8;

    if (qi::detail::sanityCheckAndReport(ds, promise))
      xMetaCall(sigret, signature, request, promise);
    return future;
  }

  inline
  void Object::emitEvent(const std::string& eventName) {
    qi::Buffer                        breq;
    qi::ODataStream                    ds(breq);
    qi::FunctorParameters             request(breq);
    std::string signature(eventName);
    signature += "::(";
    signature += ")";
    if (ds.status() != qi::ODataStream::Status_Ok)
      qiLogError("object.emit") << "Serialization error: " << (int)ds.status();
    else
      xMetaEmit(signature, request);
  }
  template <typename P0>
  void Object::emitEvent(const std::string& eventName, const P0 &p0) {
    qi::Buffer                        breq;
    qi::ODataStream                    ds(breq);
    qi::FunctorParameters             request(breq);
    ds << p0;
    std::string signature(eventName);
    signature += "::(";
    signatureFromObject::value(p0, signature);
    signature += ")";
    if (ds.status() != qi::ODataStream::Status_Ok)
      qiLogError("object.emit") << "Serialization error: " << (int)ds.status();
    else
      xMetaEmit(signature, request);
  }
  template <typename P0, typename P1>
  void Object::emitEvent(const std::string& eventName, const P0 &p0, const P1 &p1) {
    qi::Buffer                        breq;
    qi::ODataStream                    ds(breq);
    qi::FunctorParameters             request(breq);
    ds << p0;
    ds << p1;
    std::string signature(eventName);
    signature += "::(";
    signatureFromObject::value(p0, signature);
    signatureFromObject::value(p1, signature);
    signature += ")";
    if (ds.status() != qi::ODataStream::Status_Ok)
      qiLogError("object.emit") << "Serialization error: " << (int)ds.status();
    else
      xMetaEmit(signature, request);
  }
  template <typename P0, typename P1, typename P2>
  void Object::emitEvent(const std::string& eventName, const P0 &p0, const P1 &p1, const P2 &p2) {
    qi::Buffer                        breq;
    qi::ODataStream                    ds(breq);
    qi::FunctorParameters             request(breq);
    ds << p0;
    ds << p1;
    ds << p2;
    std::string signature(eventName);
    signature += "::(";
    signatureFromObject::value(p0, signature);
    signatureFromObject::value(p1, signature);
    signatureFromObject::value(p2, signature);
    signature += ")";
    if (ds.status() != qi::ODataStream::Status_Ok)
      qiLogError("object.emit") << "Serialization error: " << (int)ds.status();
    else
      xMetaEmit(signature, request);
  }
  template <typename P0, typename P1, typename P2, typename P3>
  void Object::emitEvent(const std::string& eventName, const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3) {
    qi::Buffer                        breq;
    qi::ODataStream                    ds(breq);
    qi::FunctorParameters             request(breq);
    ds << p0;
    ds << p1;
    ds << p2;
    ds << p3;
    std::string signature(eventName);
    signature += "::(";
    signatureFromObject::value(p0, signature);
    signatureFromObject::value(p1, signature);
    signatureFromObject::value(p2, signature);
    signatureFromObject::value(p3, signature);
    signature += ")";
    if (ds.status() != qi::ODataStream::Status_Ok)
      qiLogError("object.emit") << "Serialization error: " << (int)ds.status();
    else
      xMetaEmit(signature, request);
  }
  template <typename P0, typename P1, typename P2, typename P3, typename P4>
  void Object::emitEvent(const std::string& eventName, const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4) {
    qi::Buffer                        breq;
    qi::ODataStream                    ds(breq);
    qi::FunctorParameters             request(breq);
    ds << p0;
    ds << p1;
    ds << p2;
    ds << p3;
    ds << p4;
    std::string signature(eventName);
    signature += "::(";
    signatureFromObject::value(p0, signature);
    signatureFromObject::value(p1, signature);
    signatureFromObject::value(p2, signature);
    signatureFromObject::value(p3, signature);
    signatureFromObject::value(p4, signature);
    signature += ")";
    if (ds.status() != qi::ODataStream::Status_Ok)
      qiLogError("object.emit") << "Serialization error: " << (int)ds.status();
    else
      xMetaEmit(signature, request);
  }
  template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5>
  void Object::emitEvent(const std::string& eventName, const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4, const P5 &p5) {
    qi::Buffer                        breq;
    qi::ODataStream                    ds(breq);
    qi::FunctorParameters             request(breq);
    ds << p0;
    ds << p1;
    ds << p2;
    ds << p3;
    ds << p4;
    ds << p5;
    std::string signature(eventName);
    signature += "::(";
    signatureFromObject::value(p0, signature);
    signatureFromObject::value(p1, signature);
    signatureFromObject::value(p2, signature);
    signatureFromObject::value(p3, signature);
    signatureFromObject::value(p4, signature);
    signatureFromObject::value(p5, signature);
    signature += ")";
    if (ds.status() != qi::ODataStream::Status_Ok)
      qiLogError("object.emit") << "Serialization error: " << (int)ds.status();
    else
      xMetaEmit(signature, request);
  }
  template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
  void Object::emitEvent(const std::string& eventName, const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4, const P5 &p5, const P6 &p6) {
    qi::Buffer                        breq;
    qi::ODataStream                    ds(breq);
    qi::FunctorParameters             request(breq);
    ds << p0;
    ds << p1;
    ds << p2;
    ds << p3;
    ds << p4;
    ds << p5;
    ds << p6;
    std::string signature(eventName);
    signature += "::(";
    signatureFromObject::value(p0, signature);
    signatureFromObject::value(p1, signature);
    signatureFromObject::value(p2, signature);
    signatureFromObject::value(p3, signature);
    signatureFromObject::value(p4, signature);
    signatureFromObject::value(p5, signature);
    signatureFromObject::value(p6, signature);
    signature += ")";
    if (ds.status() != qi::ODataStream::Status_Ok)
      qiLogError("object.emit") << "Serialization error: " << (int)ds.status();
    else
      xMetaEmit(signature, request);
  }
  template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
  void Object::emitEvent(const std::string& eventName, const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4, const P5 &p5, const P6 &p6, const P7 &p7) {
    qi::Buffer                        breq;
    qi::ODataStream                    ds(breq);
    qi::FunctorParameters             request(breq);
    ds << p0;
    ds << p1;
    ds << p2;
    ds << p3;
    ds << p4;
    ds << p5;
    ds << p6;
    ds << p7;
    std::string signature(eventName);
    signature += "::(";
    signatureFromObject::value(p0, signature);
    signatureFromObject::value(p1, signature);
    signatureFromObject::value(p2, signature);
    signatureFromObject::value(p3, signature);
    signatureFromObject::value(p4, signature);
    signatureFromObject::value(p5, signature);
    signatureFromObject::value(p6, signature);
    signatureFromObject::value(p7, signature);
    signature += ")";
    if (ds.status() != qi::ODataStream::Status_Ok)
      qiLogError("object.emit") << "Serialization error: " << (int)ds.status();
    else
      xMetaEmit(signature, request);
  }
  template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8>
  void Object::emitEvent(const std::string& eventName, const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4, const P5 &p5, const P6 &p6, const P7 &p7, const P8 &p8) {
    qi::Buffer                        breq;
    qi::ODataStream                    ds(breq);
    qi::FunctorParameters             request(breq);
    ds << p0;
    ds << p1;
    ds << p2;
    ds << p3;
    ds << p4;
    ds << p5;
    ds << p6;
    ds << p7;
    ds << p8;
    std::string signature(eventName);
    signature += "::(";
    signatureFromObject::value(p0, signature);
    signatureFromObject::value(p1, signature);
    signatureFromObject::value(p2, signature);
    signatureFromObject::value(p3, signature);
    signatureFromObject::value(p4, signature);
    signatureFromObject::value(p5, signature);
    signatureFromObject::value(p6, signature);
    signatureFromObject::value(p7, signature);
    signatureFromObject::value(p8, signature);
    signature += ")";
    if (ds.status() != qi::ODataStream::Status_Ok)
      qiLogError("object.emit") << "Serialization error: " << (int)ds.status();
    else
      xMetaEmit(signature, request);
  }
}
#endif  // _QI_MESSAGING_OBJECT_HXX_
