/*
* AUTOGENERATED CODE, DO NOT EDIT
*
*
*  Copyright (C) 2012 Aldebaran Robotics
*/


#pragma once
#ifndef _QIMESSAGING_DETAILS_BOOSTFUNCTOR_HXX_
#define _QIMESSAGING_DETAILS_BOOSTFUNCTOR_HXX_

#include <boost/mpl/at.hpp>

# include <qimessaging/functor.hpp>
# include <boost/function_types/function_arity.hpp>
# include <boost/function_types/function_type.hpp>
# include <boost/function_types/result_type.hpp>
# include <boost/function_types/parameter_types.hpp>

namespace qi {
namespace detail {

template<int count> struct Invoker {};
template<typename T, typename R, int I> R invoke(boost::function<T>& f, const qi::FunctorParameters &params);

// I'm guessing this iteration could be avoided with fusion.
  template<> struct Invoker<0> {
  template<typename T, typename R> static
  R invoke(boost::function<T>& f, const qi::FunctorParameters &params)
  {
    typedef typename boost::function_types::parameter_types<T>::type ArgsType;
    qi::IDataStream dsi(params.buffer());
    return f();
  }
  };
  template<> struct Invoker<1> {
  template<typename T, typename R> static
  R invoke(boost::function<T>& f, const qi::FunctorParameters &params)
  {
    typedef typename boost::function_types::parameter_types<T>::type ArgsType;
    qi::IDataStream dsi(params.buffer());
    typename boost::mpl::at<ArgsType, boost::mpl::int_<0> >::type p0;
    dsi >> p0;
    return f(p0);
  }
  };
  template<> struct Invoker<2> {
  template<typename T, typename R> static
  R invoke(boost::function<T>& f, const qi::FunctorParameters &params)
  {
    typedef typename boost::function_types::parameter_types<T>::type ArgsType;
    qi::IDataStream dsi(params.buffer());
    typename boost::mpl::at<ArgsType, boost::mpl::int_<0> >::type p0;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<1> >::type p1;
    dsi >> p0;
    dsi >> p1;
    return f(p0, p1);
  }
  };
  template<> struct Invoker<3> {
  template<typename T, typename R> static
  R invoke(boost::function<T>& f, const qi::FunctorParameters &params)
  {
    typedef typename boost::function_types::parameter_types<T>::type ArgsType;
    qi::IDataStream dsi(params.buffer());
    typename boost::mpl::at<ArgsType, boost::mpl::int_<0> >::type p0;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<1> >::type p1;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<2> >::type p2;
    dsi >> p0;
    dsi >> p1;
    dsi >> p2;
    return f(p0, p1, p2);
  }
  };
  template<> struct Invoker<4> {
  template<typename T, typename R> static
  R invoke(boost::function<T>& f, const qi::FunctorParameters &params)
  {
    typedef typename boost::function_types::parameter_types<T>::type ArgsType;
    qi::IDataStream dsi(params.buffer());
    typename boost::mpl::at<ArgsType, boost::mpl::int_<0> >::type p0;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<1> >::type p1;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<2> >::type p2;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<3> >::type p3;
    dsi >> p0;
    dsi >> p1;
    dsi >> p2;
    dsi >> p3;
    return f(p0, p1, p2, p3);
  }
  };
  template<> struct Invoker<5> {
  template<typename T, typename R> static
  R invoke(boost::function<T>& f, const qi::FunctorParameters &params)
  {
    typedef typename boost::function_types::parameter_types<T>::type ArgsType;
    qi::IDataStream dsi(params.buffer());
    typename boost::mpl::at<ArgsType, boost::mpl::int_<0> >::type p0;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<1> >::type p1;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<2> >::type p2;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<3> >::type p3;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<4> >::type p4;
    dsi >> p0;
    dsi >> p1;
    dsi >> p2;
    dsi >> p3;
    dsi >> p4;
    return f(p0, p1, p2, p3, p4);
  }
  };
  template<> struct Invoker<6> {
  template<typename T, typename R> static
  R invoke(boost::function<T>& f, const qi::FunctorParameters &params)
  {
    typedef typename boost::function_types::parameter_types<T>::type ArgsType;
    qi::IDataStream dsi(params.buffer());
    typename boost::mpl::at<ArgsType, boost::mpl::int_<0> >::type p0;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<1> >::type p1;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<2> >::type p2;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<3> >::type p3;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<4> >::type p4;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<5> >::type p5;
    dsi >> p0;
    dsi >> p1;
    dsi >> p2;
    dsi >> p3;
    dsi >> p4;
    dsi >> p5;
    return f(p0, p1, p2, p3, p4, p5);
  }
  };
  template<> struct Invoker<7> {
  template<typename T, typename R> static
  R invoke(boost::function<T>& f, const qi::FunctorParameters &params)
  {
    typedef typename boost::function_types::parameter_types<T>::type ArgsType;
    qi::IDataStream dsi(params.buffer());
    typename boost::mpl::at<ArgsType, boost::mpl::int_<0> >::type p0;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<1> >::type p1;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<2> >::type p2;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<3> >::type p3;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<4> >::type p4;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<5> >::type p5;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<6> >::type p6;
    dsi >> p0;
    dsi >> p1;
    dsi >> p2;
    dsi >> p3;
    dsi >> p4;
    dsi >> p5;
    dsi >> p6;
    return f(p0, p1, p2, p3, p4, p5, p6);
  }
  };
  template<> struct Invoker<8> {
  template<typename T, typename R> static
  R invoke(boost::function<T>& f, const qi::FunctorParameters &params)
  {
    typedef typename boost::function_types::parameter_types<T>::type ArgsType;
    qi::IDataStream dsi(params.buffer());
    typename boost::mpl::at<ArgsType, boost::mpl::int_<0> >::type p0;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<1> >::type p1;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<2> >::type p2;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<3> >::type p3;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<4> >::type p4;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<5> >::type p5;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<6> >::type p6;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<7> >::type p7;
    dsi >> p0;
    dsi >> p1;
    dsi >> p2;
    dsi >> p3;
    dsi >> p4;
    dsi >> p5;
    dsi >> p6;
    dsi >> p7;
    return f(p0, p1, p2, p3, p4, p5, p6, p7);
  }
  };
  template<> struct Invoker<9> {
  template<typename T, typename R> static
  R invoke(boost::function<T>& f, const qi::FunctorParameters &params)
  {
    typedef typename boost::function_types::parameter_types<T>::type ArgsType;
    qi::IDataStream dsi(params.buffer());
    typename boost::mpl::at<ArgsType, boost::mpl::int_<0> >::type p0;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<1> >::type p1;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<2> >::type p2;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<3> >::type p3;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<4> >::type p4;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<5> >::type p5;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<6> >::type p6;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<7> >::type p7;
    typename boost::mpl::at<ArgsType, boost::mpl::int_<8> >::type p8;
    dsi >> p0;
    dsi >> p1;
    dsi >> p2;
    dsi >> p3;
    dsi >> p4;
    dsi >> p5;
    dsi >> p6;
    dsi >> p7;
    dsi >> p8;
    return f(p0, p1, p2, p3, p4, p5, p6, p7, p8);
  }
  };

  template<typename T>
  class BoostFunctor: public Functor
  {
    public:
      BoostFunctor(boost::function<T> f)
        : f(f) {}
     void call(const qi::FunctorParameters &params, qi::FunctorResult result) const
     {
       typedef typename boost::function_types::result_type<T>::type ResultType;
       Invoker<boost::function_types::function_arity<T>::value> invoker;
       ResultType res = invoker.invoke<T, ResultType>(
         const_cast<boost::function<T>&>(f), params);
       qi::Buffer     buf;
       qi::ODataStream dso(buf);
       dso << res;
       if (sanityCheckAndReport(dso, result))
          result.setValue(buf);
     }
     boost::function<T> f;
  };

}
}
#endif  // _QIMESSAGING_DETAILS_FUNCTOR_HXX_
