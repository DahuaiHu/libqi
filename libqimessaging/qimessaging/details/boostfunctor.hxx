/*
* AUTOGENERATED CODE, DO NOT EDIT
*
*
*  Copyright (C) 2012 Aldebaran Robotics
*/


#pragma once
#ifndef _QIMESSAGING_DETAILS_BOOSTFUNCTOR_HXX_
#define _QIMESSAGING_DETAILS_BOOSTFUNCTOR_HXX_

#include <boost/mpl/at.hpp>

# include <qimessaging/functor.hpp>
# include <boost/function_types/function_arity.hpp>
# include <boost/function_types/function_type.hpp>
# include <boost/function_types/result_type.hpp>
# include <boost/function_types/parameter_types.hpp>
# include <boost/type_traits/remove_const.hpp>
# include <boost/type_traits/remove_reference.hpp>
namespace qi {
namespace detail {

// Use a wrapper to avoid poluting a ',' operator on a user-visible class
class _ODWrapper
{
public:
  _ODWrapper(ODataStream& od)
  : _od(od) {}
  ODataStream& _od;
  _ODWrapper& operator()() { return *this;}
};

template<typename T> void operator ,(_ODWrapper& odw, const T& val)
{
  odw._od << val;
}


template<int count> struct Invoker {};
template<typename T, typename R, int I> R invoke(boost::function<T>& f, const qi::FunctorParameters &params);

// I'm guessing this iteration could be avoided with fusion.
  template<> struct Invoker<0> {
  template<typename T, typename R> static
  R invoke(boost::function<T>& f, const qi::FunctorParameters &params)
  {
    typedef typename boost::function_types::parameter_types<T>::type ArgsType;
    qi::IDataStream dsi(params.buffer());
    return f();
  }
  };
  template<> struct Invoker<1> {
  template<typename T, typename R> static
  R invoke(boost::function<T>& f, const qi::FunctorParameters &params)
  {
    typedef typename boost::function_types::parameter_types<T>::type ArgsType;
    qi::IDataStream dsi(params.buffer());
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<0> >::type
      >::type>::type p0;
    dsi >> p0;
    return f(p0);
  }
  };
  template<> struct Invoker<2> {
  template<typename T, typename R> static
  R invoke(boost::function<T>& f, const qi::FunctorParameters &params)
  {
    typedef typename boost::function_types::parameter_types<T>::type ArgsType;
    qi::IDataStream dsi(params.buffer());
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<0> >::type
      >::type>::type p0;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<1> >::type
      >::type>::type p1;
    dsi >> p0;
    dsi >> p1;
    return f(p0, p1);
  }
  };
  template<> struct Invoker<3> {
  template<typename T, typename R> static
  R invoke(boost::function<T>& f, const qi::FunctorParameters &params)
  {
    typedef typename boost::function_types::parameter_types<T>::type ArgsType;
    qi::IDataStream dsi(params.buffer());
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<0> >::type
      >::type>::type p0;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<1> >::type
      >::type>::type p1;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<2> >::type
      >::type>::type p2;
    dsi >> p0;
    dsi >> p1;
    dsi >> p2;
    return f(p0, p1, p2);
  }
  };
  template<> struct Invoker<4> {
  template<typename T, typename R> static
  R invoke(boost::function<T>& f, const qi::FunctorParameters &params)
  {
    typedef typename boost::function_types::parameter_types<T>::type ArgsType;
    qi::IDataStream dsi(params.buffer());
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<0> >::type
      >::type>::type p0;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<1> >::type
      >::type>::type p1;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<2> >::type
      >::type>::type p2;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<3> >::type
      >::type>::type p3;
    dsi >> p0;
    dsi >> p1;
    dsi >> p2;
    dsi >> p3;
    return f(p0, p1, p2, p3);
  }
  };
  template<> struct Invoker<5> {
  template<typename T, typename R> static
  R invoke(boost::function<T>& f, const qi::FunctorParameters &params)
  {
    typedef typename boost::function_types::parameter_types<T>::type ArgsType;
    qi::IDataStream dsi(params.buffer());
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<0> >::type
      >::type>::type p0;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<1> >::type
      >::type>::type p1;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<2> >::type
      >::type>::type p2;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<3> >::type
      >::type>::type p3;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<4> >::type
      >::type>::type p4;
    dsi >> p0;
    dsi >> p1;
    dsi >> p2;
    dsi >> p3;
    dsi >> p4;
    return f(p0, p1, p2, p3, p4);
  }
  };
  template<> struct Invoker<6> {
  template<typename T, typename R> static
  R invoke(boost::function<T>& f, const qi::FunctorParameters &params)
  {
    typedef typename boost::function_types::parameter_types<T>::type ArgsType;
    qi::IDataStream dsi(params.buffer());
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<0> >::type
      >::type>::type p0;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<1> >::type
      >::type>::type p1;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<2> >::type
      >::type>::type p2;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<3> >::type
      >::type>::type p3;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<4> >::type
      >::type>::type p4;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<5> >::type
      >::type>::type p5;
    dsi >> p0;
    dsi >> p1;
    dsi >> p2;
    dsi >> p3;
    dsi >> p4;
    dsi >> p5;
    return f(p0, p1, p2, p3, p4, p5);
  }
  };
  template<> struct Invoker<7> {
  template<typename T, typename R> static
  R invoke(boost::function<T>& f, const qi::FunctorParameters &params)
  {
    typedef typename boost::function_types::parameter_types<T>::type ArgsType;
    qi::IDataStream dsi(params.buffer());
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<0> >::type
      >::type>::type p0;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<1> >::type
      >::type>::type p1;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<2> >::type
      >::type>::type p2;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<3> >::type
      >::type>::type p3;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<4> >::type
      >::type>::type p4;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<5> >::type
      >::type>::type p5;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<6> >::type
      >::type>::type p6;
    dsi >> p0;
    dsi >> p1;
    dsi >> p2;
    dsi >> p3;
    dsi >> p4;
    dsi >> p5;
    dsi >> p6;
    return f(p0, p1, p2, p3, p4, p5, p6);
  }
  };
  template<> struct Invoker<8> {
  template<typename T, typename R> static
  R invoke(boost::function<T>& f, const qi::FunctorParameters &params)
  {
    typedef typename boost::function_types::parameter_types<T>::type ArgsType;
    qi::IDataStream dsi(params.buffer());
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<0> >::type
      >::type>::type p0;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<1> >::type
      >::type>::type p1;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<2> >::type
      >::type>::type p2;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<3> >::type
      >::type>::type p3;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<4> >::type
      >::type>::type p4;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<5> >::type
      >::type>::type p5;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<6> >::type
      >::type>::type p6;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<7> >::type
      >::type>::type p7;
    dsi >> p0;
    dsi >> p1;
    dsi >> p2;
    dsi >> p3;
    dsi >> p4;
    dsi >> p5;
    dsi >> p6;
    dsi >> p7;
    return f(p0, p1, p2, p3, p4, p5, p6, p7);
  }
  };
  template<> struct Invoker<9> {
  template<typename T, typename R> static
  R invoke(boost::function<T>& f, const qi::FunctorParameters &params)
  {
    typedef typename boost::function_types::parameter_types<T>::type ArgsType;
    qi::IDataStream dsi(params.buffer());
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<0> >::type
      >::type>::type p0;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<1> >::type
      >::type>::type p1;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<2> >::type
      >::type>::type p2;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<3> >::type
      >::type>::type p3;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<4> >::type
      >::type>::type p4;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<5> >::type
      >::type>::type p5;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<6> >::type
      >::type>::type p6;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<7> >::type
      >::type>::type p7;
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<8> >::type
      >::type>::type p8;
    dsi >> p0;
    dsi >> p1;
    dsi >> p2;
    dsi >> p3;
    dsi >> p4;
    dsi >> p5;
    dsi >> p6;
    dsi >> p7;
    dsi >> p8;
    return f(p0, p1, p2, p3, p4, p5, p6, p7, p8);
  }
  };

  template<typename T>
  class BoostFunctor: public Functor
  {
    public:
      BoostFunctor(boost::function<T> f)
        : f(f) {}
     void call(const qi::FunctorParameters &params, qi::FunctorResult result) const
     {
       typedef typename boost::function_types::result_type<T>::type ResultType;
       Invoker<boost::function_types::function_arity<T>::value> invoker;
       qi::Buffer     buf;
       qi::ODataStream dso(buf);
       _ODWrapper odw = _ODWrapper(dso);
       // Calls 'dso << invoker.invoke...', do nothing if T is void
       odw() , (ResultType) invoker.template invoke<T, ResultType>(
         const_cast<boost::function<T>&>(f), params);
       if (sanityCheckAndReport(dso, result))
          result.setValue(buf);
     }
     boost::function<T> f;
  };

}
}
#endif  // _QIMESSAGING_DETAILS_FUNCTOR_HXX_
