#from qibuild_code_generator import *
/*
* $autogen
*
*
*  Copyright (C) 2012 Aldebaran Robotics
*/

#raw

#pragma once
#ifndef _QIMESSAGING_DETAILS_BOOSTFUNCTOR_HXX_
#define _QIMESSAGING_DETAILS_BOOSTFUNCTOR_HXX_

#include <boost/mpl/at.hpp>

# include <qimessaging/functor.hpp>
# include <boost/function_types/function_arity.hpp>
# include <boost/function_types/function_type.hpp>
# include <boost/function_types/result_type.hpp>
# include <boost/function_types/parameter_types.hpp>
# include <boost/type_traits/remove_const.hpp>
# include <boost/type_traits/remove_reference.hpp>
namespace qi {
namespace detail {

// Use a wrapper to avoid poluting a ',' operator on a user-visible class
class _ODWrapper
{
public:
  _ODWrapper(ODataStream& od)
  : _od(od) {}
  ODataStream& _od;
  _ODWrapper& operator()() { return *this;}
};

template<typename T> void operator ,(_ODWrapper& odw, const T& val)
{
  odw._od << val;
}

#end raw

template<int count> struct Invoker {};
template<typename T, typename R, int I> R invoke(boost::function<T>& f, const qi::FunctorParameters &params);

// I'm guessing this iteration could be avoided with fusion.
#for $i in $count
  template<> struct Invoker<$i> {
  template<typename T, typename R> static
  R invoke(boost::function<T>& f, const qi::FunctorParameters &params)
  {
    typedef typename boost::function_types::parameter_types<T>::type ArgsType;
    qi::IDataStream dsi(params.buffer());
    #for $j in range($i)
    typename boost::remove_const<
      typename boost::remove_reference<
        typename boost::mpl::at<ArgsType, boost::mpl::int_<$j> >::type
      >::type>::type p$j;
    #end for
    #for $j in range($i)
    dsi >> p$j;
    #end for
    return f($generate_callparam_list($i));
  }
  };
#end for

  template<typename T>
  class BoostFunctor: public Functor
  {
    public:
      BoostFunctor(boost::function<T> f)
        : f(f) {}
     void call(const qi::FunctorParameters &params, qi::FunctorResult result) const
     {
       typedef typename boost::function_types::result_type<T>::type ResultType;
       Invoker<boost::function_types::function_arity<T>::value> invoker;
       qi::Buffer     buf;
       qi::ODataStream dso(buf);
       _ODWrapper odw = _ODWrapper(dso);
       // Calls 'dso << invoker.invoke...', do nothing if T is void
       odw() , (ResultType) invoker.template invoke<T, ResultType>(
         const_cast<boost::function<T>&>(f), params);
       if (sanityCheckAndReport(dso, result))
          result.setValue(buf);
     }
     boost::function<T> f;
  };

#raw
}
}
#endif  // _QIMESSAGING_DETAILS_FUNCTOR_HXX_
#end raw
