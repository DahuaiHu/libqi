/*
* AUTOGENERATED CODE, DO NOT EDIT
*
*  Author(s):
*  - Cedric GESTES <gestes@aldebaran-robotics.com>
*
*  Copyright (C) 2010, 2011, 2012 Aldebaran Robotics
*/

#pragma once
#ifndef _QIMESSAGING_DETAILS_MEMBERFUNCTOR_HXX_
#define _QIMESSAGING_DETAILS_MEMBERFUNCTOR_HXX_

#include <qimessaging/functor.hpp>

namespace qi {
namespace detail {

  template < typename C, typename R>
  class MemberFunctor_0 : public Functor
  {
  public:
    typedef R(C::*FunctionType) ();

    MemberFunctor_0(C *pObject, FunctionType pFunction)
      : fObject(pObject),
        fFunction(pFunction)
    {}

    R operator()() {
      return (R)(fObject->*fFunction)();
    }

    void call(const qi::FunctorParameters &params, qi::FunctorResult result) const {
      QI_FUNCTOR_ASSUME_NBR_PARAMS(params, 0);
      qi::IDataStream  dsi(params.buffer());
      qi::Buffer      buf;
      qi::ODataStream  dso(buf);

      if (sanityCheckAndReport(dsi, result)) {
        dso << (fObject->*fFunction)();
        if (sanityCheckAndReport(dso, result))
          result.setValue(buf);
      }
    };
  private:
    C            *fObject;
    FunctionType  fFunction;
  };

  template <typename P0,  typename C, typename R>
  class MemberFunctor_1 : public Functor
  {
  public:
    typedef R(C::*FunctionType) (const P0 &p0);

    MemberFunctor_1(C *pObject, FunctionType pFunction)
      : fObject(pObject),
        fFunction(pFunction)
    {}

    R operator()(const P0 &p0) {
      return (R)(fObject->*fFunction)(p0);
    }

    void call(const qi::FunctorParameters &params, qi::FunctorResult result) const {
      QI_FUNCTOR_ASSUME_NBR_PARAMS(params, 1);
      qi::IDataStream  dsi(params.buffer());
      qi::Buffer      buf;
      qi::ODataStream  dso(buf);
      P0 p0;

      dsi >> p0;
      if (sanityCheckAndReport(dsi, result)) {
        dso << (fObject->*fFunction)(p0);
        if (sanityCheckAndReport(dso, result))
          result.setValue(buf);
      }
    };
  private:
    C            *fObject;
    FunctionType  fFunction;
  };

  template <typename P0, typename P1,  typename C, typename R>
  class MemberFunctor_2 : public Functor
  {
  public:
    typedef R(C::*FunctionType) (const P0 &p0, const P1 &p1);

    MemberFunctor_2(C *pObject, FunctionType pFunction)
      : fObject(pObject),
        fFunction(pFunction)
    {}

    R operator()(const P0 &p0, const P1 &p1) {
      return (R)(fObject->*fFunction)(p0, p1);
    }

    void call(const qi::FunctorParameters &params, qi::FunctorResult result) const {
      QI_FUNCTOR_ASSUME_NBR_PARAMS(params, 2);
      qi::IDataStream  dsi(params.buffer());
      qi::Buffer      buf;
      qi::ODataStream  dso(buf);
      P0 p0;
      P1 p1;

      dsi >> p0;
      dsi >> p1;
      if (sanityCheckAndReport(dsi, result)) {
        dso << (fObject->*fFunction)(p0, p1);
        if (sanityCheckAndReport(dso, result))
          result.setValue(buf);
      }
    };
  private:
    C            *fObject;
    FunctionType  fFunction;
  };

  template <typename P0, typename P1, typename P2,  typename C, typename R>
  class MemberFunctor_3 : public Functor
  {
  public:
    typedef R(C::*FunctionType) (const P0 &p0, const P1 &p1, const P2 &p2);

    MemberFunctor_3(C *pObject, FunctionType pFunction)
      : fObject(pObject),
        fFunction(pFunction)
    {}

    R operator()(const P0 &p0, const P1 &p1, const P2 &p2) {
      return (R)(fObject->*fFunction)(p0, p1, p2);
    }

    void call(const qi::FunctorParameters &params, qi::FunctorResult result) const {
      QI_FUNCTOR_ASSUME_NBR_PARAMS(params, 3);
      qi::IDataStream  dsi(params.buffer());
      qi::Buffer      buf;
      qi::ODataStream  dso(buf);
      P0 p0;
      P1 p1;
      P2 p2;

      dsi >> p0;
      dsi >> p1;
      dsi >> p2;
      if (sanityCheckAndReport(dsi, result)) {
        dso << (fObject->*fFunction)(p0, p1, p2);
        if (sanityCheckAndReport(dso, result))
          result.setValue(buf);
      }
    };
  private:
    C            *fObject;
    FunctionType  fFunction;
  };

  template <typename P0, typename P1, typename P2, typename P3,  typename C, typename R>
  class MemberFunctor_4 : public Functor
  {
  public:
    typedef R(C::*FunctionType) (const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3);

    MemberFunctor_4(C *pObject, FunctionType pFunction)
      : fObject(pObject),
        fFunction(pFunction)
    {}

    R operator()(const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3) {
      return (R)(fObject->*fFunction)(p0, p1, p2, p3);
    }

    void call(const qi::FunctorParameters &params, qi::FunctorResult result) const {
      QI_FUNCTOR_ASSUME_NBR_PARAMS(params, 4);
      qi::IDataStream  dsi(params.buffer());
      qi::Buffer      buf;
      qi::ODataStream  dso(buf);
      P0 p0;
      P1 p1;
      P2 p2;
      P3 p3;

      dsi >> p0;
      dsi >> p1;
      dsi >> p2;
      dsi >> p3;
      if (sanityCheckAndReport(dsi, result)) {
        dso << (fObject->*fFunction)(p0, p1, p2, p3);
        if (sanityCheckAndReport(dso, result))
          result.setValue(buf);
      }
    };
  private:
    C            *fObject;
    FunctionType  fFunction;
  };

  template <typename P0, typename P1, typename P2, typename P3, typename P4,  typename C, typename R>
  class MemberFunctor_5 : public Functor
  {
  public:
    typedef R(C::*FunctionType) (const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4);

    MemberFunctor_5(C *pObject, FunctionType pFunction)
      : fObject(pObject),
        fFunction(pFunction)
    {}

    R operator()(const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4) {
      return (R)(fObject->*fFunction)(p0, p1, p2, p3, p4);
    }

    void call(const qi::FunctorParameters &params, qi::FunctorResult result) const {
      QI_FUNCTOR_ASSUME_NBR_PARAMS(params, 5);
      qi::IDataStream  dsi(params.buffer());
      qi::Buffer      buf;
      qi::ODataStream  dso(buf);
      P0 p0;
      P1 p1;
      P2 p2;
      P3 p3;
      P4 p4;

      dsi >> p0;
      dsi >> p1;
      dsi >> p2;
      dsi >> p3;
      dsi >> p4;
      if (sanityCheckAndReport(dsi, result)) {
        dso << (fObject->*fFunction)(p0, p1, p2, p3, p4);
        if (sanityCheckAndReport(dso, result))
          result.setValue(buf);
      }
    };
  private:
    C            *fObject;
    FunctionType  fFunction;
  };

  template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5,  typename C, typename R>
  class MemberFunctor_6 : public Functor
  {
  public:
    typedef R(C::*FunctionType) (const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4, const P5 &p5);

    MemberFunctor_6(C *pObject, FunctionType pFunction)
      : fObject(pObject),
        fFunction(pFunction)
    {}

    R operator()(const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4, const P5 &p5) {
      return (R)(fObject->*fFunction)(p0, p1, p2, p3, p4, p5);
    }

    void call(const qi::FunctorParameters &params, qi::FunctorResult result) const {
      QI_FUNCTOR_ASSUME_NBR_PARAMS(params, 6);
      qi::IDataStream  dsi(params.buffer());
      qi::Buffer      buf;
      qi::ODataStream  dso(buf);
      P0 p0;
      P1 p1;
      P2 p2;
      P3 p3;
      P4 p4;
      P5 p5;

      dsi >> p0;
      dsi >> p1;
      dsi >> p2;
      dsi >> p3;
      dsi >> p4;
      dsi >> p5;
      if (sanityCheckAndReport(dsi, result)) {
        dso << (fObject->*fFunction)(p0, p1, p2, p3, p4, p5);
        if (sanityCheckAndReport(dso, result))
          result.setValue(buf);
      }
    };
  private:
    C            *fObject;
    FunctionType  fFunction;
  };

  template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6,  typename C, typename R>
  class MemberFunctor_7 : public Functor
  {
  public:
    typedef R(C::*FunctionType) (const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4, const P5 &p5, const P6 &p6);

    MemberFunctor_7(C *pObject, FunctionType pFunction)
      : fObject(pObject),
        fFunction(pFunction)
    {}

    R operator()(const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4, const P5 &p5, const P6 &p6) {
      return (R)(fObject->*fFunction)(p0, p1, p2, p3, p4, p5, p6);
    }

    void call(const qi::FunctorParameters &params, qi::FunctorResult result) const {
      QI_FUNCTOR_ASSUME_NBR_PARAMS(params, 7);
      qi::IDataStream  dsi(params.buffer());
      qi::Buffer      buf;
      qi::ODataStream  dso(buf);
      P0 p0;
      P1 p1;
      P2 p2;
      P3 p3;
      P4 p4;
      P5 p5;
      P6 p6;

      dsi >> p0;
      dsi >> p1;
      dsi >> p2;
      dsi >> p3;
      dsi >> p4;
      dsi >> p5;
      dsi >> p6;
      if (sanityCheckAndReport(dsi, result)) {
        dso << (fObject->*fFunction)(p0, p1, p2, p3, p4, p5, p6);
        if (sanityCheckAndReport(dso, result))
          result.setValue(buf);
      }
    };
  private:
    C            *fObject;
    FunctionType  fFunction;
  };

  template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7,  typename C, typename R>
  class MemberFunctor_8 : public Functor
  {
  public:
    typedef R(C::*FunctionType) (const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4, const P5 &p5, const P6 &p6, const P7 &p7);

    MemberFunctor_8(C *pObject, FunctionType pFunction)
      : fObject(pObject),
        fFunction(pFunction)
    {}

    R operator()(const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4, const P5 &p5, const P6 &p6, const P7 &p7) {
      return (R)(fObject->*fFunction)(p0, p1, p2, p3, p4, p5, p6, p7);
    }

    void call(const qi::FunctorParameters &params, qi::FunctorResult result) const {
      QI_FUNCTOR_ASSUME_NBR_PARAMS(params, 8);
      qi::IDataStream  dsi(params.buffer());
      qi::Buffer      buf;
      qi::ODataStream  dso(buf);
      P0 p0;
      P1 p1;
      P2 p2;
      P3 p3;
      P4 p4;
      P5 p5;
      P6 p6;
      P7 p7;

      dsi >> p0;
      dsi >> p1;
      dsi >> p2;
      dsi >> p3;
      dsi >> p4;
      dsi >> p5;
      dsi >> p6;
      dsi >> p7;
      if (sanityCheckAndReport(dsi, result)) {
        dso << (fObject->*fFunction)(p0, p1, p2, p3, p4, p5, p6, p7);
        if (sanityCheckAndReport(dso, result))
          result.setValue(buf);
      }
    };
  private:
    C            *fObject;
    FunctionType  fFunction;
  };

  template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8,  typename C, typename R>
  class MemberFunctor_9 : public Functor
  {
  public:
    typedef R(C::*FunctionType) (const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4, const P5 &p5, const P6 &p6, const P7 &p7, const P8 &p8);

    MemberFunctor_9(C *pObject, FunctionType pFunction)
      : fObject(pObject),
        fFunction(pFunction)
    {}

    R operator()(const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4, const P5 &p5, const P6 &p6, const P7 &p7, const P8 &p8) {
      return (R)(fObject->*fFunction)(p0, p1, p2, p3, p4, p5, p6, p7, p8);
    }

    void call(const qi::FunctorParameters &params, qi::FunctorResult result) const {
      QI_FUNCTOR_ASSUME_NBR_PARAMS(params, 9);
      qi::IDataStream  dsi(params.buffer());
      qi::Buffer      buf;
      qi::ODataStream  dso(buf);
      P0 p0;
      P1 p1;
      P2 p2;
      P3 p3;
      P4 p4;
      P5 p5;
      P6 p6;
      P7 p7;
      P8 p8;

      dsi >> p0;
      dsi >> p1;
      dsi >> p2;
      dsi >> p3;
      dsi >> p4;
      dsi >> p5;
      dsi >> p6;
      dsi >> p7;
      dsi >> p8;
      if (sanityCheckAndReport(dsi, result)) {
        dso << (fObject->*fFunction)(p0, p1, p2, p3, p4, p5, p6, p7, p8);
        if (sanityCheckAndReport(dso, result))
          result.setValue(buf);
      }
    };
  private:
    C            *fObject;
    FunctionType  fFunction;
  };

}
}
#endif  // _QIMESSAGING_DETAILS_MEMBERFUNCTOR_HXX_
