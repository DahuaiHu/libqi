#from qibuild_code_generator import *
/*
* $autogen
*
*  Author(s):
*  - Cedric GESTES <gestes@aldebaran-robotics.com>
*  - Chris  Kilner <ckilner@aldebaran-robotics.com>
*
*  Copyright (C) 2010, 2011, 2012 Aldebaran Robotics
*/

#raw

#pragma once
#ifndef _QIMESSAGING_DETAILS_FUNCTOR_HXX_
#define _QIMESSAGING_DETAILS_FUNCTOR_HXX_

# include <qimessaging/functor.hpp>

namespace qi {
namespace detail {
#end raw
#for $i in $count

  template <$generate_typename_list($i, end = True) typename R>
  class Functor_${i} : public Functor
  {
  public:
    typedef R(*FunctionType) ($generate_param_list($i));

    Functor_${i}(FunctionType pFunction)
      : fFunction(pFunction)
    {}

    R operator()($generate_param_list($i)) {
      return (R)(*fFunction)($generate_arg_list($i));
    }

    void call(const qi::FunctorParameters &params, qi::FunctorResult result) const {
      QI_FUNCTOR_ASSUME_NBR_PARAMS(params, ${i});
      qi::DataStream dsi(params.buffer());
      qi::Buffer     buf;
      qi::DataStream dso(buf);
      #for $j in range($i)
      P$j p$j;
      #end for
      #for $j in range($i)
      dsi >> p$j;
      #end for

      if (sanityCheckAndReport(dsi, result)) {
        dso << (*fFunction)($generate_callparam_list($i));
        if (sanityCheckAndReport(dso, result))
          result.setValue(buf);
      }
    };

  private:
    FunctionType  fFunction;
  };

#end for
#raw
}
}
#endif  // _QIMESSAGING_DETAILS_FUNCTOR_HXX_
#end raw
