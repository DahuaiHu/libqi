== QiMessaging ToDo ==

General:
  - basic ACL => filters?
  - move functor to messaging/src

Messaging:
  - run should be blocking -> thread should be managed by user. (we could provide a start/stop/wait alternative)
  - Fast Local Call ? => maybe it only belong to the client library of each services

pub/sub:
  - what about the concept of pipe or port ?
    do we need one way connect (for example robot client behind xmpp gateway) but both way stream?
    maybe the xmpp remote want to stream data to the robot, be it voice, sensors, ...

Goals/Tasks:
  - define an API
  - send a message, receive messages for progression, receive a reply
  - progress messages are optional.
  - we want t = Task.start("address", data, ..), t.{start,stop,wait}
  - t.registerProgressCallback, t.registerCompletionCallback

Events:
  - define an API, maybe events are only

Distributed Memory:
  - the memory is spread across each process and machine.
  - only owner can write to memory. each process can have one or more owners. owners are restricted to one process.
  - each process has direct access to all others local process memories
  - part of remote memory can be automatically replicated ?

Transport:
  - Client/Subscriber: handle timeout on connect/call/read
  - let the possibility to avoid thread in server/subscriber. (add a receive method)
  - look at ACE shm backend
  - look at Android IPC Binder
  - auto beatheart for each connections. dont be too rude

Master:
  - support importing and storing complete services/topics types.
  - support protobuf and ros format?
  - client can query the master to have a full description of each services/topics
  - description could be '{s(sm)}' where 's' are names, and '(sm)' pairs of name, and m where m could be
    a type 's' , or another description map '{s(sm)}'
  - '{s(sm)}' = std::map<std::string, boost::tuple<std::string, qi::TypedMessage> >

Client:
  - implement listServices::s:
  - implement listTopics::s:
  - implement describeService
  - implement describeTopic

Gateway:
  - gateway only provide client implementation ? can call method on the robot, can subscribe to data.

Signature:
  - support tuple '(...)'
  - message 'm'

Serialization:
  - implement a zerocopy buffer
  - implement a pool of zerocp buffer
  - use that in all backend
  - support inlined (no alloc) message (for short message) (we use preallocated block of getpagesize())

Doc:
  - document signature format
  - document message format

Test:
  - test_serialization (base the test on test_boost_serialization)
  - more test
  - test coverage
  - valgrind
  - fusing test on message/signature combination

Tracing:
  - timestamp
  - bandwitdh
  - service/topics introspection
  - who use who?

C++:
  - proper public API separation: QIAPI (not applicable for header only stuff)
  - find a name for connect (register, registerWithMaster, signin, ..)
  - merge client and subscriber
  - merge server and publisher
  - lazy private implementation instanciation
  - support tuple and typedmessage

C:
  - proper public API separation: QIAPI (not applicable for header only stuff)
  - doc
  - wrap pub/sub
  - unittest + perf test

Python:
  - doc
  - wrap pub/sub
  - proper unittest
  - add perftest
  - rename p* to _*
  - error handling (raise exceptions)



