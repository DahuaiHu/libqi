/*
** AUTOGENERATED CODE, DO NOT EDIT
**
** Author(s):
**  - Cedric GESTES <gestes@aldebaran-robotics.com>
**
** Copyright (C) 2010 Aldebaran Robotics
*/

#ifndef  AL_MESSAGING_MAKE_FUNCTOR_HPP_
# define AL_MESSAGING_MAKE_FUNCTOR_HPP_

#include <alcommon-ng/functor/functor.hpp>

#include <boost/function_types/function_type.hpp>
#include <boost/function_types/is_member_function_pointer.hpp>
#include <boost/type_traits/is_member_function_pointer.hpp>

namespace AL
{
//  template <typename F>
//  Functor *makeFun(F f) {
//    boost::is_member_pointer<F>::type t;
//    boost::function_types::function_type<F>::arity
//  }
//  is_function
//  is_function_pointer
//  is_function_reference
//  is_member_pointer
//  is_member_object_pointer
//  is_member_function_pointer
//  is_callable_builtin
//  is_nonmember_callable_builtin


  template <typename C, typename R>
  Functor *makeFunctor(C *obj, R (C::*f) ()) {
    return new MemberFunctor_0<C, R>(obj, f);
  }

  template <typename R>
  Functor *makeFunctor(R (*f) ()) {
    return new Functor_0<R>(f);
  }


  template <typename P0, typename C, typename R>
  Functor *makeFunctor(C *obj, R (C::*f) (const P0 &p0)) {
    return new MemberFunctor_1<P0, C, R>(obj, f);
  }

  template <typename P0, typename R>
  Functor *makeFunctor(R (*f) (const P0 &p0)) {
    return new Functor_1<P0, R>(f);
  }


  template <typename P0, typename P1, typename C, typename R>
  Functor *makeFunctor(C *obj, R (C::*f) (const P0 &p0, const P1 &p1)) {
    return new MemberFunctor_2<P0, P1, C, R>(obj, f);
  }

  template <typename P0, typename P1, typename R>
  Functor *makeFunctor(R (*f) (const P0 &p0, const P1 &p1)) {
    return new Functor_2<P0, P1, R>(f);
  }


  template <typename P0, typename P1, typename P2, typename C, typename R>
  Functor *makeFunctor(C *obj, R (C::*f) (const P0 &p0, const P1 &p1, const P2 &p2)) {
    return new MemberFunctor_3<P0, P1, P2, C, R>(obj, f);
  }

  template <typename P0, typename P1, typename P2, typename R>
  Functor *makeFunctor(R (*f) (const P0 &p0, const P1 &p1, const P2 &p2)) {
    return new Functor_3<P0, P1, P2, R>(f);
  }


  template <typename P0, typename P1, typename P2, typename P3, typename C, typename R>
  Functor *makeFunctor(C *obj, R (C::*f) (const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3)) {
    return new MemberFunctor_4<P0, P1, P2, P3, C, R>(obj, f);
  }

  template <typename P0, typename P1, typename P2, typename P3, typename R>
  Functor *makeFunctor(R (*f) (const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3)) {
    return new Functor_4<P0, P1, P2, P3, R>(f);
  }


  template <typename P0, typename P1, typename P2, typename P3, typename P4, typename C, typename R>
  Functor *makeFunctor(C *obj, R (C::*f) (const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4)) {
    return new MemberFunctor_5<P0, P1, P2, P3, P4, C, R>(obj, f);
  }

  template <typename P0, typename P1, typename P2, typename P3, typename P4, typename R>
  Functor *makeFunctor(R (*f) (const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4)) {
    return new Functor_5<P0, P1, P2, P3, P4, R>(f);
  }


  template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename C, typename R>
  Functor *makeFunctor(C *obj, R (C::*f) (const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4, const P5 &p5)) {
    return new MemberFunctor_6<P0, P1, P2, P3, P4, P5, C, R>(obj, f);
  }

  template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename R>
  Functor *makeFunctor(R (*f) (const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4, const P5 &p5)) {
    return new Functor_6<P0, P1, P2, P3, P4, P5, R>(f);
  }

}
#endif
