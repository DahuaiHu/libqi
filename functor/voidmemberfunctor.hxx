//AUTOGENERATED HEADER DO NOT EDIT
/*
** Author(s):
**  - Cedric GESTES <gestes@aldebaran-robotics.com>
**
** Copyright (C) 2010 Aldebaran Robotics
*/

#ifndef I_WANT_HXX
#error "do not include hxx in your code"
#endif

#ifndef  AL_MESSAGING_VOID_MEMBER_FUNCTOR_HXX_
# define AL_MESSAGING_VOID_MEMBER_FUNCTOR_HXX_

# include <alcommon-ng/functor/functor.hpp>

namespace AL
{

  template <typename C>
  class MemberFunctor_0<C, void> : public Functor
  {
  public:
    typedef void(C::*FunctionType) ();

    MemberFunctor_0(C *pObject, FunctionType pFunction)
      : fObject(pObject),
        fFunction(pFunction) {
    }

    void operator()() {
      (fObject->*fFunction)();
    }

    void call(const AL::Messaging::ArgumentList &params, AL::Messaging::ReturnValue&) {
      AL_FUNCTOR_ASSUME_NBR_PARAMS(params, 0);
      (fObject->*fFunction)();
    };

  private:
    C            *fObject;
    FunctionType  fFunction;
  };


  template <typename P0, typename C>
  class MemberFunctor_1<P0, C, void> : public Functor
  {
  public:
    typedef void(C::*FunctionType) (const P0 &p0);

    MemberFunctor_1(C *pObject, FunctionType pFunction)
      : fObject(pObject),
        fFunction(pFunction) {
    }

    void operator()(const P0 &p0) {
      (fObject->*fFunction)(p0);
    }

    void call(const AL::Messaging::ArgumentList &params, AL::Messaging::ReturnValue&) {
      AL_FUNCTOR_ASSUME_NBR_PARAMS(params, 1);
      (fObject->*fFunction)(params[0].as<P0>());
    };

  private:
    C            *fObject;
    FunctionType  fFunction;
  };


  template <typename P0, typename P1, typename C>
  class MemberFunctor_2<P0, P1, C, void> : public Functor
  {
  public:
    typedef void(C::*FunctionType) (const P0 &p0, const P1 &p1);

    MemberFunctor_2(C *pObject, FunctionType pFunction)
      : fObject(pObject),
        fFunction(pFunction) {
    }

    void operator()(const P0 &p0, const P1 &p1) {
      (fObject->*fFunction)(p0, p1);
    }

    void call(const AL::Messaging::ArgumentList &params, AL::Messaging::ReturnValue&) {
      AL_FUNCTOR_ASSUME_NBR_PARAMS(params, 2);
      (fObject->*fFunction)(params[0].as<P0>(), params[1].as<P1>());
    };

  private:
    C            *fObject;
    FunctionType  fFunction;
  };


  template <typename P0, typename P1, typename P2, typename C>
  class MemberFunctor_3<P0, P1, P2, C, void> : public Functor
  {
  public:
    typedef void(C::*FunctionType) (const P0 &p0, const P1 &p1, const P2 &p2);

    MemberFunctor_3(C *pObject, FunctionType pFunction)
      : fObject(pObject),
        fFunction(pFunction) {
    }

    void operator()(const P0 &p0, const P1 &p1, const P2 &p2) {
      (fObject->*fFunction)(p0, p1, p2);
    }

    void call(const AL::Messaging::ArgumentList &params, AL::Messaging::ReturnValue&) {
      AL_FUNCTOR_ASSUME_NBR_PARAMS(params, 3);
      (fObject->*fFunction)(params[0].as<P0>(), params[1].as<P1>(), params[2].as<P2>());
    };

  private:
    C            *fObject;
    FunctionType  fFunction;
  };


  template <typename P0, typename P1, typename P2, typename P3, typename C>
  class MemberFunctor_4<P0, P1, P2, P3, C, void> : public Functor
  {
  public:
    typedef void(C::*FunctionType) (const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3);

    MemberFunctor_4(C *pObject, FunctionType pFunction)
      : fObject(pObject),
        fFunction(pFunction) {
    }

    void operator()(const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3) {
      (fObject->*fFunction)(p0, p1, p2, p3);
    }

    void call(const AL::Messaging::ArgumentList &params, AL::Messaging::ReturnValue&) {
      AL_FUNCTOR_ASSUME_NBR_PARAMS(params, 4);
      (fObject->*fFunction)(params[0].as<P0>(), params[1].as<P1>(), params[2].as<P2>(), params[3].as<P3>());
    };

  private:
    C            *fObject;
    FunctionType  fFunction;
  };


  template <typename P0, typename P1, typename P2, typename P3, typename P4, typename C>
  class MemberFunctor_5<P0, P1, P2, P3, P4, C, void> : public Functor
  {
  public:
    typedef void(C::*FunctionType) (const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4);

    MemberFunctor_5(C *pObject, FunctionType pFunction)
      : fObject(pObject),
        fFunction(pFunction) {
    }

    void operator()(const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4) {
      (fObject->*fFunction)(p0, p1, p2, p3, p4);
    }

    void call(const AL::Messaging::ArgumentList &params, AL::Messaging::ReturnValue&) {
      AL_FUNCTOR_ASSUME_NBR_PARAMS(params, 5);
      (fObject->*fFunction)(params[0].as<P0>(), params[1].as<P1>(), params[2].as<P2>(), params[3].as<P3>(), params[4].as<P4>());
    };

  private:
    C            *fObject;
    FunctionType  fFunction;
  };


  template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename C>
  class MemberFunctor_6<P0, P1, P2, P3, P4, P5, C, void> : public Functor
  {
  public:
    typedef void(C::*FunctionType) (const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4, const P5 &p5);

    MemberFunctor_6(C *pObject, FunctionType pFunction)
      : fObject(pObject),
        fFunction(pFunction) {
    }

    void operator()(const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4, const P5 &p5) {
      (fObject->*fFunction)(p0, p1, p2, p3, p4, p5);
    }

    void call(const AL::Messaging::ArgumentList &params, AL::Messaging::ReturnValue&) {
      AL_FUNCTOR_ASSUME_NBR_PARAMS(params, 6);
      (fObject->*fFunction)(params[0].as<P0>(), params[1].as<P1>(), params[2].as<P2>(), params[3].as<P3>(), params[4].as<P4>(), params[5].as<P5>());
    };

  private:
    C            *fObject;
    FunctionType  fFunction;
  };

}
#endif
