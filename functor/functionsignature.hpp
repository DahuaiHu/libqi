/*
** AUTOGENERATED CODE, DO NOT EDIT
**
** Author(s):
**  - Cedric GESTES <gestes@aldebaran-robotics.com>
**
** Copyright (C) 2010 Aldebaran Robotics
*/

#ifndef  AL_MESSAGING_FUNCTION_SIGNATURE_HPP_
# define AL_MESSAGING_FUNCTION_SIGNATURE_HPP_

#include <alcommon-ng/functor/typesignature.hpp>

namespace AL
{
  template <  typename C, typename R >
  std::string functionSignature(R (C::*f) ()) {
    std::string result;
    AL::typeSignature<R>::value(result);
    result += ":";
    return result;
  }

  template < typename R >
  std::string functionSignature(R (*f) ()) {
    std::string result;
    AL::typeSignature<R>::value(result);
    result += ":";
    return result;
  }


  template < typename P0,  typename C, typename R >
  std::string functionSignature(R (C::*f) (const P0 &p0)) {
    std::string result;
    AL::typeSignature<R>::value(result);
    result += ":";
    AL::typeSignature<P0>::value(result);
    return result;
  }

  template < typename P0, typename R >
  std::string functionSignature(R (*f) (const P0 &p0)) {
    std::string result;
    AL::typeSignature<R>::value(result);
    result += ":";
    AL::typeSignature<P0>::value(result);
    return result;
  }


  template < typename P0, typename P1,  typename C, typename R >
  std::string functionSignature(R (C::*f) (const P0 &p0, const P1 &p1)) {
    std::string result;
    AL::typeSignature<R>::value(result);
    result += ":";
    AL::typeSignature<P0>::value(result);
    AL::typeSignature<P1>::value(result);
    return result;
  }

  template < typename P0, typename P1, typename R >
  std::string functionSignature(R (*f) (const P0 &p0, const P1 &p1)) {
    std::string result;
    AL::typeSignature<R>::value(result);
    result += ":";
    AL::typeSignature<P0>::value(result);
    AL::typeSignature<P1>::value(result);
    return result;
  }


  template < typename P0, typename P1, typename P2,  typename C, typename R >
  std::string functionSignature(R (C::*f) (const P0 &p0, const P1 &p1, const P2 &p2)) {
    std::string result;
    AL::typeSignature<R>::value(result);
    result += ":";
    AL::typeSignature<P0>::value(result);
    AL::typeSignature<P1>::value(result);
    AL::typeSignature<P2>::value(result);
    return result;
  }

  template < typename P0, typename P1, typename P2, typename R >
  std::string functionSignature(R (*f) (const P0 &p0, const P1 &p1, const P2 &p2)) {
    std::string result;
    AL::typeSignature<R>::value(result);
    result += ":";
    AL::typeSignature<P0>::value(result);
    AL::typeSignature<P1>::value(result);
    AL::typeSignature<P2>::value(result);
    return result;
  }


  template < typename P0, typename P1, typename P2, typename P3,  typename C, typename R >
  std::string functionSignature(R (C::*f) (const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3)) {
    std::string result;
    AL::typeSignature<R>::value(result);
    result += ":";
    AL::typeSignature<P0>::value(result);
    AL::typeSignature<P1>::value(result);
    AL::typeSignature<P2>::value(result);
    AL::typeSignature<P3>::value(result);
    return result;
  }

  template < typename P0, typename P1, typename P2, typename P3, typename R >
  std::string functionSignature(R (*f) (const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3)) {
    std::string result;
    AL::typeSignature<R>::value(result);
    result += ":";
    AL::typeSignature<P0>::value(result);
    AL::typeSignature<P1>::value(result);
    AL::typeSignature<P2>::value(result);
    AL::typeSignature<P3>::value(result);
    return result;
  }


  template < typename P0, typename P1, typename P2, typename P3, typename P4,  typename C, typename R >
  std::string functionSignature(R (C::*f) (const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4)) {
    std::string result;
    AL::typeSignature<R>::value(result);
    result += ":";
    AL::typeSignature<P0>::value(result);
    AL::typeSignature<P1>::value(result);
    AL::typeSignature<P2>::value(result);
    AL::typeSignature<P3>::value(result);
    AL::typeSignature<P4>::value(result);
    return result;
  }

  template < typename P0, typename P1, typename P2, typename P3, typename P4, typename R >
  std::string functionSignature(R (*f) (const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4)) {
    std::string result;
    AL::typeSignature<R>::value(result);
    result += ":";
    AL::typeSignature<P0>::value(result);
    AL::typeSignature<P1>::value(result);
    AL::typeSignature<P2>::value(result);
    AL::typeSignature<P3>::value(result);
    AL::typeSignature<P4>::value(result);
    return result;
  }


  template < typename P0, typename P1, typename P2, typename P3, typename P4, typename P5,  typename C, typename R >
  std::string functionSignature(R (C::*f) (const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4, const P5 &p5)) {
    std::string result;
    AL::typeSignature<R>::value(result);
    result += ":";
    AL::typeSignature<P0>::value(result);
    AL::typeSignature<P1>::value(result);
    AL::typeSignature<P2>::value(result);
    AL::typeSignature<P3>::value(result);
    AL::typeSignature<P4>::value(result);
    AL::typeSignature<P5>::value(result);
    return result;
  }

  template < typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename R >
  std::string functionSignature(R (*f) (const P0 &p0, const P1 &p1, const P2 &p2, const P3 &p3, const P4 &p4, const P5 &p5)) {
    std::string result;
    AL::typeSignature<R>::value(result);
    result += ":";
    AL::typeSignature<P0>::value(result);
    AL::typeSignature<P1>::value(result);
    AL::typeSignature<P2>::value(result);
    AL::typeSignature<P3>::value(result);
    AL::typeSignature<P4>::value(result);
    AL::typeSignature<P5>::value(result);
    return result;
  }

  template<typename F>
  std::string makeSignature(const std::string name, F f) {
    return name + std::string("::") + functionSignature(f);
  }
}

#endif
