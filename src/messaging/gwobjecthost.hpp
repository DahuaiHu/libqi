#pragma once
/*
** Copyright (C) 2014 Aldebaran Robotics
** See COPYING for the license
*/

#ifndef _SRC_MESSAGING_GWOBJECTHOST_HPP_
#define _SRC_MESSAGING_GWOBJECTHOST_HPP_

#include <map>
#include <utility>
#include <vector>
#include <list>

#include <boost/shared_ptr.hpp>
#include <boost/thread.hpp>

#include <qi/atomic.hpp>
#include <qi/type/metaobject.hpp>
#include <boost/container/flat_map.hpp>

using ServiceId = unsigned int;
using ObjectId = unsigned int;
using GwObjectId = unsigned int;
// This structure represent the address of the object within the client.
// The same object can have multiple, different addresses if the client passes it
// to multiple services.
struct ObjectAddress
{
  ServiceId service;
  ObjectId object;
  ObjectAddress()
  {
  }
  ObjectAddress(const ObjectAddress& o)
    : service(o.service)
    , object(o.object)
  {
  }
  ObjectAddress(ServiceId s, ObjectId o)
    : service(s)
    , object(o)
  {
  }
  bool operator==(const ObjectAddress& o) const
  {
    return o.service == service && o.object == object;
  }
  bool operator<(const ObjectAddress& o) const
  {
    return (service == o.service && object < o.object) || service < o.service;
  }
};

namespace qi
{
class MetaObject;
class Message;
class TransportSocket;
class GwTransaction;
using TransportSocketPtr = boost::shared_ptr<TransportSocket>;
using TransportSocketWeakPtr = boost::weak_ptr<TransportSocket>;

/// Describes the full address of an object.
struct FullObjectAddress
{
  /// The socket from which the object is originated.
  TransportSocketWeakPtr socket;

  /// The address of the object over the associated socket.
  ObjectAddress localAddress;
};
struct ObjectInfo
{
  TransportSocketPtr socket;
  ObjectAddress address;
};

/// The gateway is a hub of sockets forwarding the qimessaging protocol.
/// When objects are transmitted from one end to another, the identifiers
/// used for services as well as for objects over each of the sockets are
/// unknown from one socket to another. To prevent ID collision and to be able
/// to forward object-related messages from one end to another, the Gateway
/// Object Host creates a unique Gateway ID for every object found in the
/// forwarded messages. As a consequence, every message entering the gateway
/// is translated so that any object address involved is translated accordingly
/// to the IDs the destination knows.
class GwObjectHost
{
public:
  ~GwObjectHost();

  /// Translate object IDs from message accordingly to the sender and the
  /// destination. When an object is found from an incoming message, an ID is
  /// generated, so that any further call on the object can be properly
  /// forwarded by adapting the destination specified in the message. More
  /// precisely, clients receiving an object from the gateway will know it
  /// under the ID generated by the gateway, so they need the gateway to set
  /// the original ID to he message.
  void treatMessage(GwTransaction& msg, TransportSocketPtr sender, qi::TransportSocketPtr destination);
  void serviceDisconnected(ServiceId);
  void clientDisconnected(TransportSocketPtr);

  void harvestClientReplyOriginatingObjects(Message& msg, TransportSocketPtr sender, GwObjectId id, TransportSocketPtr destination);
  void harvestClientCallOriginatingObjects(Message& msg, TransportSocketPtr sender, TransportSocketPtr destination);
  void harvestServiceOriginatingObjects(Message& msg, TransportSocketPtr sender, qi::TransportSocketPtr destination);
  void harvestMessageObjects(Message& msg, TransportSocketPtr sender, qi::TransportSocketPtr destination);

  ObjectAddress getOriginalObjectAddress(const ObjectAddress& gwObjectAddress);
  ObjectInfo objectSource(const ObjectAddress&  address);

  /// Use this method to remember to which socket an object was transmitted.
  /// @param destination The destination socket.
  /// @param origin The origin socket.
  /// @param objectAddress The local address of the object over the origin socket.
  void setDestinationSocketForObject(
      const TransportSocketPtr& destination,
      const TransportSocketPtr& origin,
      const ObjectAddress& objectAddress);

  /// Try to find the socket to communicate with a given service.
  /// The sockets are collected when harvesting and no metaobject was found.
  /// Can return null if no socket was found.
  /// If several sockets are possible, returns the first one.
  /// Warning: Use this only as a last resort.
  TransportSocketPtr findInUnknownMetaObjectSockets(ServiceId);

private:
  void assignClientMessageObjectsGwIds(const Signature& sig, Message& msg, TransportSocketPtr sender, qi::TransportSocketPtr destination);

  boost::shared_mutex _mutex;

  // Objects originating from services
  // TODO OPTI: stocker une methodmap a la place du metaobject.
  // Retirer les methodes de la map quand elles sont appelees et qu'il y a pas d'object dedans.
  // -> devrait faire gagner du temps
  std::map<ServiceId, std::map<ObjectId, MetaObject> > _servicesMetaObjects;
  // All objects that a service uses - needed so that they can be invalidated if the
  // service goes offline.
  std::map<ServiceId, std::list<GwObjectId> > _objectsUsedOnServices;

  // Objects originating from clients
  std::map<GwObjectId, MetaObject> _objectsMetaObjects;


  // Tracks the connection between a GWObjectId and a client + messageaddress
  std::map<GwObjectId, ObjectInfo> _objectsOrigin;

  /// The origin of objects that are transmitted to clients are remembered here.
  std::map<TransportSocketPtr, std::list<FullObjectAddress>> _objectOriginsPerDestination;

  std::map<TransportSocketPtr, std::map<ObjectAddress, GwObjectId> > _hostObjectBank;

  MetaObject* findMetaObject(ServiceId serviceId, ObjectId objectId);

  boost::container::flat_map<ServiceId, std::map<ObjectId, TransportSocketPtr>> _unknownMetaObjectSockets;
};
}

#endif
